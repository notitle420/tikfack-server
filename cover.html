
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tikfack/server/cmd/app/main.go (0.0%)</option>
				
				<option value="file1">github.com/tikfack/server/gen/video/video.pb.go (0.0%)</option>
				
				<option value="file2">github.com/tikfack/server/gen/video/videoconnect/video.connect.go (0.0%)</option>
				
				<option value="file3">github.com/tikfack/server/internal/application/usecase/mock/mock_video_usecase.go (0.0%)</option>
				
				<option value="file4">github.com/tikfack/server/internal/application/usecase/video/video_usecase.go (100.0%)</option>
				
				<option value="file5">github.com/tikfack/server/internal/domain/repository/mock/mock_video_repository.go (0.0%)</option>
				
				<option value="file6">github.com/tikfack/server/internal/infrastructure/connect/mock/mock_video_service_server.go (0.0%)</option>
				
				<option value="file7">github.com/tikfack/server/internal/infrastructure/connect/video_handler.go (90.7%)</option>
				
				<option value="file8">github.com/tikfack/server/internal/infrastructure/dmmapi/client.go (86.7%)</option>
				
				<option value="file9">github.com/tikfack/server/internal/infrastructure/dmmapi/dmm_respository.go (94.8%)</option>
				
				<option value="file10">github.com/tikfack/server/internal/infrastructure/dmmapi/mapper.go (100.0%)</option>
				
				<option value="file11">github.com/tikfack/server/internal/infrastructure/dmmapi/mock_client.go (100.0%)</option>
				
				<option value="file12">github.com/tikfack/server/internal/infrastructure/dmmapi/mock_mapper.go (100.0%)</option>
				
				<option value="file13">github.com/tikfack/server/internal/infrastructure/repository/video_repository.go (0.0%)</option>
				
				<option value="file14">github.com/tikfack/server/internal/infrastructure/util/video_util.go (94.1%)</option>
				
				<option value="file15">github.com/tikfack/server/main.go (0.0%)</option>
				
				<option value="file16">github.com/tikfack/server/test/mockserver/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"
        "net/http"
        "os"

        "github.com/tikfack/server/internal/infrastructure/connect"

        "github.com/joho/godotenv"
        "github.com/rs/cors"
        // Connect ハンドラー実装
)

func main() <span class="cov0" title="0">{
        // .env の読み込み
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: .env ファイルの読み込みに失敗しました: %v", err)
        }</span>
        <span class="cov0" title="0">port := os.Getenv("PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "50051"
        }</span>

        // Connect ハンドラーの初期化
        <span class="cov0" title="0">handler := connect.NewVideoServiceHandler()

        mux := http.NewServeMux()
        // Connect サービスのパターンとハンドラーを登録
        pattern, h := handler.GetHandler()
        mux.Handle(pattern, h)

        // CORS 設定を適用
        handlerWithCORS := cors.AllowAll().Handler(mux)
        log.Printf("Connect gRPC server is running on :%s", port)
        if err := http.ListenAndServe(":"+port, handlerWithCORS); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to serve: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.5
//         protoc        (unknown)
// source: video/video.proto

package video

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// 各属性用のメッセージ定義（IDと名前）
type Actress struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Actress) Reset() <span class="cov0" title="0">{
        *x = Actress{}
        mi := &amp;file_video_video_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Actress) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Actress) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Actress) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Actress.ProtoReflect.Descriptor instead.
func (*Actress) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Actress) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Actress) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Genre struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Genre) Reset() <span class="cov0" title="0">{
        *x = Genre{}
        mi := &amp;file_video_video_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Genre) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Genre) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Genre) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Genre.ProtoReflect.Descriptor instead.
func (*Genre) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{1}
}</span>

func (x *Genre) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Genre) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Maker struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Maker) Reset() <span class="cov0" title="0">{
        *x = Maker{}
        mi := &amp;file_video_video_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Maker) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Maker) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Maker) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Maker.ProtoReflect.Descriptor instead.
func (*Maker) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{2}
}</span>

func (x *Maker) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Maker) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Series struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Series) Reset() <span class="cov0" title="0">{
        *x = Series{}
        mi := &amp;file_video_video_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Series) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Series) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Series) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Series.ProtoReflect.Descriptor instead.
func (*Series) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{3}
}</span>

func (x *Series) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Series) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Director struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Director) Reset() <span class="cov0" title="0">{
        *x = Director{}
        mi := &amp;file_video_video_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Director) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Director) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Director) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Director.ProtoReflect.Descriptor instead.
func (*Director) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{4}
}</span>

func (x *Director) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Director) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// レビュー情報
type Review struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Count         int32                  `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
        Average       float32                `protobuf:"fixed32,2,opt,name=average,proto3" json:"average,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Review) Reset() <span class="cov0" title="0">{
        *x = Review{}
        mi := &amp;file_video_video_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Review) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Review) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Review) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Review.ProtoReflect.Descriptor instead.
func (*Review) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{5}
}</span>

func (x *Review) GetCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Count
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Review) GetAverage() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Average
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Videoメッセージを重要度順に並び替え
type Video struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        DmmId         string                 `protobuf:"bytes,1,opt,name=dmm_id,json=dmmId,proto3" json:"dmm_id,omitempty"`
        Title         string                 `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
        DirectUrl     string                 `protobuf:"bytes,3,opt,name=direct_url,json=directUrl,proto3" json:"direct_url,omitempty"`
        Url           string                 `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
        SampleUrl     string                 `protobuf:"bytes,5,opt,name=sample_url,json=sampleUrl,proto3" json:"sample_url,omitempty"`
        ThumbnailUrl  string                 `protobuf:"bytes,6,opt,name=thumbnail_url,json=thumbnailUrl,proto3" json:"thumbnail_url,omitempty"`
        CreatedAt     string                 `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        Price         int32                  `protobuf:"varint,8,opt,name=price,proto3" json:"price,omitempty"`
        LikesCount    int32                  `protobuf:"varint,9,opt,name=likes_count,json=likesCount,proto3" json:"likes_count,omitempty"`
        Actresses     []*Actress             `protobuf:"bytes,10,rep,name=actresses,proto3" json:"actresses,omitempty"`
        Genres        []*Genre               `protobuf:"bytes,11,rep,name=genres,proto3" json:"genres,omitempty"`
        Makers        []*Maker               `protobuf:"bytes,12,rep,name=makers,proto3" json:"makers,omitempty"`
        Series        []*Series              `protobuf:"bytes,13,rep,name=series,proto3" json:"series,omitempty"`
        Directors     []*Director            `protobuf:"bytes,14,rep,name=directors,proto3" json:"directors,omitempty"`
        Review        *Review                `protobuf:"bytes,15,opt,name=review,proto3" json:"review,omitempty"` // レビュー情報
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Video) Reset() <span class="cov0" title="0">{
        *x = Video{}
        mi := &amp;file_video_video_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Video) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Video) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Video) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Video.ProtoReflect.Descriptor instead.
func (*Video) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{6}
}</span>

func (x *Video) GetDmmId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DmmId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Video) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Video) GetDirectUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DirectUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Video) GetUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Url
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Video) GetSampleUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SampleUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Video) GetThumbnailUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ThumbnailUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Video) GetCreatedAt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Video) GetPrice() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Price
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Video) GetLikesCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LikesCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Video) GetActresses() []*Actress <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Actresses
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Video) GetGenres() []*Genre <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Genres
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Video) GetMakers() []*Maker <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Makers
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Video) GetSeries() []*Series <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Series
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Video) GetDirectors() []*Director <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Directors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Video) GetReview() *Review <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Review
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetVideosByDateRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Date          string                 `protobuf:"bytes,1,opt,name=date,proto3" json:"date,omitempty"` // Optional date filter
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetVideosByDateRequest) Reset() <span class="cov0" title="0">{
        *x = GetVideosByDateRequest{}
        mi := &amp;file_video_video_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetVideosByDateRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetVideosByDateRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetVideosByDateRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetVideosByDateRequest.ProtoReflect.Descriptor instead.
func (*GetVideosByDateRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{7}
}</span>

func (x *GetVideosByDateRequest) GetDate() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Date
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetVideosByDateResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Videos        []*Video               `protobuf:"bytes,1,rep,name=videos,proto3" json:"videos,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetVideosByDateResponse) Reset() <span class="cov0" title="0">{
        *x = GetVideosByDateResponse{}
        mi := &amp;file_video_video_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetVideosByDateResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetVideosByDateResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetVideosByDateResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetVideosByDateResponse.ProtoReflect.Descriptor instead.
func (*GetVideosByDateResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{8}
}</span>

func (x *GetVideosByDateResponse) GetVideos() []*Video <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Videos
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetVideoByIdRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        DmmId         string                 `protobuf:"bytes,1,opt,name=dmm_id,json=dmmId,proto3" json:"dmm_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetVideoByIdRequest) Reset() <span class="cov0" title="0">{
        *x = GetVideoByIdRequest{}
        mi := &amp;file_video_video_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetVideoByIdRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetVideoByIdRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetVideoByIdRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetVideoByIdRequest.ProtoReflect.Descriptor instead.
func (*GetVideoByIdRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{9}
}</span>

func (x *GetVideoByIdRequest) GetDmmId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DmmId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetVideoByIdResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Video         *Video                 `protobuf:"bytes,1,opt,name=video,proto3" json:"video,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetVideoByIdResponse) Reset() <span class="cov0" title="0">{
        *x = GetVideoByIdResponse{}
        mi := &amp;file_video_video_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetVideoByIdResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetVideoByIdResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetVideoByIdResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetVideoByIdResponse.ProtoReflect.Descriptor instead.
func (*GetVideoByIdResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{10}
}</span>

func (x *GetVideoByIdResponse) GetVideo() *Video <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Video
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ID指定による検索用メッセージ（すべてのフィールドはoptional）
type GetVideosByIDRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ActressId     []string               `protobuf:"bytes,1,rep,name=actress_id,json=actressId,proto3" json:"actress_id,omitempty"`    // 女優ID（複数指定可能、空でも可）
        GenreId       []string               `protobuf:"bytes,2,rep,name=genre_id,json=genreId,proto3" json:"genre_id,omitempty"`          // ジャンルID（複数指定可能、空でも可）
        MakerId       []string               `protobuf:"bytes,3,rep,name=maker_id,json=makerId,proto3" json:"maker_id,omitempty"`          // メーカーID（複数指定可能、空でも可）
        SeriesId      []string               `protobuf:"bytes,4,rep,name=series_id,json=seriesId,proto3" json:"series_id,omitempty"`       // シリーズID（複数指定可能、空でも可）
        DirectorId    []string               `protobuf:"bytes,5,rep,name=director_id,json=directorId,proto3" json:"director_id,omitempty"` // 監督ID（複数指定可能、空でも可）
        Hits          int32                  `protobuf:"varint,6,opt,name=hits,proto3" json:"hits,omitempty"`                              // 取得件数（初期値：20、最大：100、省略可）
        Offset        int32                  `protobuf:"varint,7,opt,name=offset,proto3" json:"offset,omitempty"`                          // 検索開始位置（初期値：1、最大：50000、省略可）
        Sort          string                 `protobuf:"bytes,8,opt,name=sort,proto3" json:"sort,omitempty"`                               // ソート順（rank：人気順、price：価格が高い順、-price：価格が安い順、date：発売日順、review：評価順、match：マッチング順、省略可）
        GteDate       string                 `protobuf:"bytes,9,opt,name=gte_date,json=gteDate,proto3" json:"gte_date,omitempty"`          // 発売日絞り込み（この日付以降、ISO8601形式 YYYY-MM-DDT00:00:00、省略可）
        LteDate       string                 `protobuf:"bytes,10,opt,name=lte_date,json=lteDate,proto3" json:"lte_date,omitempty"`         // 発売日絞り込み（この日付以前、ISO8601形式 YYYY-MM-DDT00:00:00、省略可）
        Site          string                 `protobuf:"bytes,11,opt,name=site,proto3" json:"site,omitempty"`                              // サイト（FANZA または DMM.com、省略可）
        Service       string                 `protobuf:"bytes,12,opt,name=service,proto3" json:"service,omitempty"`                        // サービス（例：digital、省略可）
        Floor         string                 `protobuf:"bytes,13,opt,name=floor,proto3" json:"floor,omitempty"`                            // フロア（例：videoa、省略可）
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetVideosByIDRequest) Reset() <span class="cov0" title="0">{
        *x = GetVideosByIDRequest{}
        mi := &amp;file_video_video_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetVideosByIDRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetVideosByIDRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetVideosByIDRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetVideosByIDRequest.ProtoReflect.Descriptor instead.
func (*GetVideosByIDRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{11}
}</span>

func (x *GetVideosByIDRequest) GetActressId() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ActressId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetVideosByIDRequest) GetGenreId() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GenreId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetVideosByIDRequest) GetMakerId() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MakerId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetVideosByIDRequest) GetSeriesId() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SeriesId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetVideosByIDRequest) GetDirectorId() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DirectorId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetVideosByIDRequest) GetHits() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Hits
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetVideosByIDRequest) GetOffset() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetVideosByIDRequest) GetSort() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sort
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetVideosByIDRequest) GetGteDate() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GteDate
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetVideosByIDRequest) GetLteDate() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LteDate
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetVideosByIDRequest) GetSite() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Site
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetVideosByIDRequest) GetService() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Service
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetVideosByIDRequest) GetFloor() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Floor
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// キーワードによる検索用メッセージ（すべてのフィールドはoptional）
type GetVideosByKeywordRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Keyword       string                 `protobuf:"bytes,1,opt,name=keyword,proto3" json:"keyword,omitempty"`                // 検索キーワード（省略可）
        Hits          int32                  `protobuf:"varint,2,opt,name=hits,proto3" json:"hits,omitempty"`                     // 取得件数（初期値：20、最大：100、省略可）
        Offset        int32                  `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`                 // 検索開始位置（初期値：1、最大：50000、省略可）
        Sort          string                 `protobuf:"bytes,4,opt,name=sort,proto3" json:"sort,omitempty"`                      // ソート順（rank：人気順、price：価格が高い順、-price：価格が安い順、date：発売日順、review：評価順、match：マッチング順、省略可）
        GteDate       string                 `protobuf:"bytes,5,opt,name=gte_date,json=gteDate,proto3" json:"gte_date,omitempty"` // 発売日絞り込み（この日付以降、ISO8601形式 YYYY-MM-DDT00:00:00、省略可）
        LteDate       string                 `protobuf:"bytes,6,opt,name=lte_date,json=lteDate,proto3" json:"lte_date,omitempty"` // 発売日絞り込み（この日付以前、ISO8601形式 YYYY-MM-DDT00:00:00、省略可）
        Site          string                 `protobuf:"bytes,7,opt,name=site,proto3" json:"site,omitempty"`                      // サイト（FANZA または DMM.com、省略可）
        Service       string                 `protobuf:"bytes,8,opt,name=service,proto3" json:"service,omitempty"`                // サービス（例：digital、省略可）
        Floor         string                 `protobuf:"bytes,9,opt,name=floor,proto3" json:"floor,omitempty"`                    // フロア（例：videoa、省略可）
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetVideosByKeywordRequest) Reset() <span class="cov0" title="0">{
        *x = GetVideosByKeywordRequest{}
        mi := &amp;file_video_video_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetVideosByKeywordRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetVideosByKeywordRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetVideosByKeywordRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetVideosByKeywordRequest.ProtoReflect.Descriptor instead.
func (*GetVideosByKeywordRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{12}
}</span>

func (x *GetVideosByKeywordRequest) GetKeyword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Keyword
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetVideosByKeywordRequest) GetHits() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Hits
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetVideosByKeywordRequest) GetOffset() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetVideosByKeywordRequest) GetSort() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sort
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetVideosByKeywordRequest) GetGteDate() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GteDate
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetVideosByKeywordRequest) GetLteDate() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LteDate
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetVideosByKeywordRequest) GetSite() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Site
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetVideosByKeywordRequest) GetService() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Service
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetVideosByKeywordRequest) GetFloor() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Floor
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// 検索結果レスポンス
type GetVideosByIDResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Videos        []*Video               `protobuf:"bytes,1,rep,name=videos,proto3" json:"videos,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetVideosByIDResponse) Reset() <span class="cov0" title="0">{
        *x = GetVideosByIDResponse{}
        mi := &amp;file_video_video_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetVideosByIDResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetVideosByIDResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetVideosByIDResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetVideosByIDResponse.ProtoReflect.Descriptor instead.
func (*GetVideosByIDResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{13}
}</span>

func (x *GetVideosByIDResponse) GetVideos() []*Video <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Videos
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// 検索結果レスポンス
type GetVideosByKeywordResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Videos        []*Video               `protobuf:"bytes,1,rep,name=videos,proto3" json:"videos,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetVideosByKeywordResponse) Reset() <span class="cov0" title="0">{
        *x = GetVideosByKeywordResponse{}
        mi := &amp;file_video_video_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetVideosByKeywordResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetVideosByKeywordResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetVideosByKeywordResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetVideosByKeywordResponse.ProtoReflect.Descriptor instead.
func (*GetVideosByKeywordResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{14}
}</span>

func (x *GetVideosByKeywordResponse) GetVideos() []*Video <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Videos
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// 後方互換性のための検索用メッセージ（DMM API v3 パラメータに基づく）
type SearchVideosRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Keyword       string                 `protobuf:"bytes,1,opt,name=keyword,proto3" json:"keyword,omitempty"`                         // Optional keyword
        ActressId     string                 `protobuf:"bytes,2,opt,name=actress_id,json=actressId,proto3" json:"actress_id,omitempty"`    // 女優ID
        GenreId       string                 `protobuf:"bytes,3,opt,name=genre_id,json=genreId,proto3" json:"genre_id,omitempty"`          // ジャンルID
        MakerId       string                 `protobuf:"bytes,4,opt,name=maker_id,json=makerId,proto3" json:"maker_id,omitempty"`          // メーカーID
        SeriesId      string                 `protobuf:"bytes,5,opt,name=series_id,json=seriesId,proto3" json:"series_id,omitempty"`       // シリーズID
        DirectorId    string                 `protobuf:"bytes,6,opt,name=director_id,json=directorId,proto3" json:"director_id,omitempty"` // 監督ID
        Hits          int32                  `protobuf:"varint,7,opt,name=hits,proto3" json:"hits,omitempty"`                              // 取得件数（初期値：20、最大：100）
        Offset        int32                  `protobuf:"varint,8,opt,name=offset,proto3" json:"offset,omitempty"`                          // 検索開始位置（初期値：1、最大：50000）
        Sort          string                 `protobuf:"bytes,9,opt,name=sort,proto3" json:"sort,omitempty"`                               // ソート順（rank：人気順、price：価格が高い順、-price：価格が安い順、date：発売日順、review：評価順、match：マッチング順）
        GteDate       string                 `protobuf:"bytes,10,opt,name=gte_date,json=gteDate,proto3" json:"gte_date,omitempty"`         // 発売日絞り込み（この日付以降、ISO8601形式 YYYY-MM-DDT00:00:00）
        LteDate       string                 `protobuf:"bytes,11,opt,name=lte_date,json=lteDate,proto3" json:"lte_date,omitempty"`         // 発売日絞り込み（この日付以前、ISO8601形式 YYYY-MM-DDT00:00:00）
        Site          string                 `protobuf:"bytes,12,opt,name=site,proto3" json:"site,omitempty"`                              // サイト（FANZA または DMM.com）
        Service       string                 `protobuf:"bytes,13,opt,name=service,proto3" json:"service,omitempty"`                        // サービス（例：digital）
        Floor         string                 `protobuf:"bytes,14,opt,name=floor,proto3" json:"floor,omitempty"`                            // フロア（例：videoa）
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SearchVideosRequest) Reset() <span class="cov0" title="0">{
        *x = SearchVideosRequest{}
        mi := &amp;file_video_video_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SearchVideosRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SearchVideosRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SearchVideosRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SearchVideosRequest.ProtoReflect.Descriptor instead.
func (*SearchVideosRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{15}
}</span>

func (x *SearchVideosRequest) GetKeyword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Keyword
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchVideosRequest) GetActressId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ActressId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchVideosRequest) GetGenreId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GenreId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchVideosRequest) GetMakerId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MakerId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchVideosRequest) GetSeriesId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SeriesId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchVideosRequest) GetDirectorId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DirectorId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchVideosRequest) GetHits() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Hits
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SearchVideosRequest) GetOffset() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SearchVideosRequest) GetSort() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sort
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchVideosRequest) GetGteDate() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GteDate
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchVideosRequest) GetLteDate() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LteDate
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchVideosRequest) GetSite() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Site
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchVideosRequest) GetService() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Service
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchVideosRequest) GetFloor() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Floor
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SearchVideosResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Videos        []*Video               `protobuf:"bytes,1,rep,name=videos,proto3" json:"videos,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SearchVideosResponse) Reset() <span class="cov0" title="0">{
        *x = SearchVideosResponse{}
        mi := &amp;file_video_video_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SearchVideosResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SearchVideosResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SearchVideosResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_video_video_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SearchVideosResponse.ProtoReflect.Descriptor instead.
func (*SearchVideosResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_video_video_proto_rawDescGZIP(), []int{16}
}</span>

func (x *SearchVideosResponse) GetVideos() []*Video <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Videos
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_video_video_proto protoreflect.FileDescriptor

var file_video_video_proto_rawDesc = string([]byte{
        0x0a, 0x11, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x2f, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x12, 0x05, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x22, 0x2d, 0x0a, 0x07, 0x41, 0x63,
        0x74, 0x72, 0x65, 0x73, 0x73, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x2b, 0x0a, 0x05, 0x47, 0x65, 0x6e,
        0x72, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02,
        0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x2b, 0x0a, 0x05, 0x4d, 0x61, 0x6b, 0x65, 0x72, 0x12,
        0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12,
        0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e,
        0x61, 0x6d, 0x65, 0x22, 0x2c, 0x0a, 0x06, 0x53, 0x65, 0x72, 0x69, 0x65, 0x73, 0x12, 0x0e, 0x0a,
        0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a,
        0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x22, 0x2e, 0x0a, 0x08, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x0e, 0x0a,
        0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a,
        0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x22, 0x38, 0x0a, 0x06, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x12, 0x14, 0x0a, 0x05, 0x63,
        0x6f, 0x75, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x63, 0x6f, 0x75, 0x6e,
        0x74, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x76, 0x65, 0x72, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x02, 0x52, 0x07, 0x61, 0x76, 0x65, 0x72, 0x61, 0x67, 0x65, 0x22, 0xf6, 0x03, 0x0a, 0x05,
        0x56, 0x69, 0x64, 0x65, 0x6f, 0x12, 0x15, 0x0a, 0x06, 0x64, 0x6d, 0x6d, 0x5f, 0x69, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x64, 0x6d, 0x6d, 0x49, 0x64, 0x12, 0x14, 0x0a, 0x05,
        0x74, 0x69, 0x74, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x69, 0x74,
        0x6c, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x5f, 0x75, 0x72, 0x6c,
        0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x55, 0x72,
        0x6c, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
        0x75, 0x72, 0x6c, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x5f, 0x75, 0x72,
        0x6c, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x55,
        0x72, 0x6c, 0x12, 0x23, 0x0a, 0x0d, 0x74, 0x68, 0x75, 0x6d, 0x62, 0x6e, 0x61, 0x69, 0x6c, 0x5f,
        0x75, 0x72, 0x6c, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x74, 0x68, 0x75, 0x6d, 0x62,
        0x6e, 0x61, 0x69, 0x6c, 0x55, 0x72, 0x6c, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74,
        0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x63, 0x72, 0x65,
        0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x70, 0x72, 0x69, 0x63, 0x65, 0x18,
        0x08, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x70, 0x72, 0x69, 0x63, 0x65, 0x12, 0x1f, 0x0a, 0x0b,
        0x6c, 0x69, 0x6b, 0x65, 0x73, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28,
        0x05, 0x52, 0x0a, 0x6c, 0x69, 0x6b, 0x65, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x2c, 0x0a,
        0x09, 0x61, 0x63, 0x74, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x0b,
        0x32, 0x0e, 0x2e, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x2e, 0x41, 0x63, 0x74, 0x72, 0x65, 0x73, 0x73,
        0x52, 0x09, 0x61, 0x63, 0x74, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x12, 0x24, 0x0a, 0x06, 0x67,
        0x65, 0x6e, 0x72, 0x65, 0x73, 0x18, 0x0b, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x76, 0x69,
        0x64, 0x65, 0x6f, 0x2e, 0x47, 0x65, 0x6e, 0x72, 0x65, 0x52, 0x06, 0x67, 0x65, 0x6e, 0x72, 0x65,
        0x73, 0x12, 0x24, 0x0a, 0x06, 0x6d, 0x61, 0x6b, 0x65, 0x72, 0x73, 0x18, 0x0c, 0x20, 0x03, 0x28,
        0x0b, 0x32, 0x0c, 0x2e, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x2e, 0x4d, 0x61, 0x6b, 0x65, 0x72, 0x52,
        0x06, 0x6d, 0x61, 0x6b, 0x65, 0x72, 0x73, 0x12, 0x25, 0x0a, 0x06, 0x73, 0x65, 0x72, 0x69, 0x65,
        0x73, 0x18, 0x0d, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x2e,
        0x53, 0x65, 0x72, 0x69, 0x65, 0x73, 0x52, 0x06, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x12, 0x2d,
        0x0a, 0x09, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x18, 0x0e, 0x20, 0x03, 0x28,
        0x0b, 0x32, 0x0f, 0x2e, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x2e, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74,
        0x6f, 0x72, 0x52, 0x09, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x12, 0x25, 0x0a,
        0x06, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e,
        0x76, 0x69, 0x64, 0x65, 0x6f, 0x2e, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x06, 0x72, 0x65,
        0x76, 0x69, 0x65, 0x77, 0x22, 0x2c, 0x0a, 0x16, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64, 0x65, 0x6f,
        0x73, 0x42, 0x79, 0x44, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12,
        0x0a, 0x04, 0x64, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x64, 0x61,
        0x74, 0x65, 0x22, 0x3f, 0x0a, 0x17, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x73, 0x42,
        0x79, 0x44, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x24, 0x0a,
        0x06, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0c, 0x2e,
        0x76, 0x69, 0x64, 0x65, 0x6f, 0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x52, 0x06, 0x76, 0x69, 0x64,
        0x65, 0x6f, 0x73, 0x22, 0x2c, 0x0a, 0x13, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x42,
        0x79, 0x49, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x15, 0x0a, 0x06, 0x64, 0x6d,
        0x6d, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x64, 0x6d, 0x6d, 0x49,
        0x64, 0x22, 0x3a, 0x0a, 0x14, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x42, 0x79, 0x49,
        0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x22, 0x0a, 0x05, 0x76, 0x69, 0x64,
        0x65, 0x6f, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x76, 0x69, 0x64, 0x65, 0x6f,
        0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x52, 0x05, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x22, 0xe3, 0x02,
        0x0a, 0x14, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x73, 0x42, 0x79, 0x49, 0x44, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x61, 0x63, 0x74, 0x72, 0x65, 0x73,
        0x73, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x09, 0x61, 0x63, 0x74, 0x72,
        0x65, 0x73, 0x73, 0x49, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x67, 0x65, 0x6e, 0x72, 0x65, 0x5f, 0x69,
        0x64, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x67, 0x65, 0x6e, 0x72, 0x65, 0x49, 0x64,
        0x12, 0x19, 0x0a, 0x08, 0x6d, 0x61, 0x6b, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x03,
        0x28, 0x09, 0x52, 0x07, 0x6d, 0x61, 0x6b, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x73,
        0x65, 0x72, 0x69, 0x65, 0x73, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08,
        0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x49, 0x64, 0x12, 0x1f, 0x0a, 0x0b, 0x64, 0x69, 0x72, 0x65,
        0x63, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0a, 0x64,
        0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x49, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x68, 0x69, 0x74,
        0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x68, 0x69, 0x74, 0x73, 0x12, 0x16, 0x0a,
        0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x6f,
        0x66, 0x66, 0x73, 0x65, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x6f, 0x72, 0x74, 0x18, 0x08, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x04, 0x73, 0x6f, 0x72, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x67, 0x74, 0x65,
        0x5f, 0x64, 0x61, 0x74, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x67, 0x74, 0x65,
        0x44, 0x61, 0x74, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x6c, 0x74, 0x65, 0x5f, 0x64, 0x61, 0x74, 0x65,
        0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6c, 0x74, 0x65, 0x44, 0x61, 0x74, 0x65, 0x12,
        0x12, 0x0a, 0x04, 0x73, 0x69, 0x74, 0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x73,
        0x69, 0x74, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x18, 0x0c,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x14, 0x0a,
        0x05, 0x66, 0x6c, 0x6f, 0x6f, 0x72, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x66, 0x6c,
        0x6f, 0x6f, 0x72, 0x22, 0xef, 0x01, 0x0a, 0x19, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64, 0x65, 0x6f,
        0x73, 0x42, 0x79, 0x4b, 0x65, 0x79, 0x77, 0x6f, 0x72, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x12, 0x18, 0x0a, 0x07, 0x6b, 0x65, 0x79, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x07, 0x6b, 0x65, 0x79, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x68,
        0x69, 0x74, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x68, 0x69, 0x74, 0x73, 0x12,
        0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x6f, 0x72, 0x74, 0x18,
        0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x73, 0x6f, 0x72, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x67,
        0x74, 0x65, 0x5f, 0x64, 0x61, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x67,
        0x74, 0x65, 0x44, 0x61, 0x74, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x6c, 0x74, 0x65, 0x5f, 0x64, 0x61,
        0x74, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6c, 0x74, 0x65, 0x44, 0x61, 0x74,
        0x65, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x74, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x04, 0x73, 0x69, 0x74, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
        0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12,
        0x14, 0x0a, 0x05, 0x66, 0x6c, 0x6f, 0x6f, 0x72, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
        0x66, 0x6c, 0x6f, 0x6f, 0x72, 0x22, 0x3d, 0x0a, 0x15, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64, 0x65,
        0x6f, 0x73, 0x42, 0x79, 0x49, 0x44, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x24,
        0x0a, 0x06, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0c,
        0x2e, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x52, 0x06, 0x76, 0x69,
        0x64, 0x65, 0x6f, 0x73, 0x22, 0x42, 0x0a, 0x1a, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64, 0x65, 0x6f,
        0x73, 0x42, 0x79, 0x4b, 0x65, 0x79, 0x77, 0x6f, 0x72, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x12, 0x24, 0x0a, 0x06, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x73, 0x18, 0x01, 0x20, 0x03,
        0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f,
        0x52, 0x06, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x73, 0x22, 0xfc, 0x02, 0x0a, 0x13, 0x53, 0x65, 0x61,
        0x72, 0x63, 0x68, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x18, 0x0a, 0x07, 0x6b, 0x65, 0x79, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x07, 0x6b, 0x65, 0x79, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x61, 0x63,
        0x74, 0x72, 0x65, 0x73, 0x73, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09,
        0x61, 0x63, 0x74, 0x72, 0x65, 0x73, 0x73, 0x49, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x67, 0x65, 0x6e,
        0x72, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x67, 0x65, 0x6e,
        0x72, 0x65, 0x49, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x6d, 0x61, 0x6b, 0x65, 0x72, 0x5f, 0x69, 0x64,
        0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x61, 0x6b, 0x65, 0x72, 0x49, 0x64, 0x12,
        0x1b, 0x0a, 0x09, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x08, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x49, 0x64, 0x12, 0x1f, 0x0a, 0x0b,
        0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x0a, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x49, 0x64, 0x12, 0x12, 0x0a,
        0x04, 0x68, 0x69, 0x74, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x68, 0x69, 0x74,
        0x73, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28,
        0x05, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x6f, 0x72,
        0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x73, 0x6f, 0x72, 0x74, 0x12, 0x19, 0x0a,
        0x08, 0x67, 0x74, 0x65, 0x5f, 0x64, 0x61, 0x74, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x07, 0x67, 0x74, 0x65, 0x44, 0x61, 0x74, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x6c, 0x74, 0x65, 0x5f,
        0x64, 0x61, 0x74, 0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6c, 0x74, 0x65, 0x44,
        0x61, 0x74, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x74, 0x65, 0x18, 0x0c, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x04, 0x73, 0x69, 0x74, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69,
        0x63, 0x65, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
        0x65, 0x12, 0x14, 0x0a, 0x05, 0x66, 0x6c, 0x6f, 0x6f, 0x72, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x05, 0x66, 0x6c, 0x6f, 0x6f, 0x72, 0x22, 0x3c, 0x0a, 0x14, 0x53, 0x65, 0x61, 0x72, 0x63,
        0x68, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x24, 0x0a, 0x06, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x0c, 0x2e, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x52, 0x06, 0x76,
        0x69, 0x64, 0x65, 0x6f, 0x73, 0x32, 0x99, 0x03, 0x0a, 0x0c, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x53,
        0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x50, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64,
        0x65, 0x6f, 0x73, 0x42, 0x79, 0x44, 0x61, 0x74, 0x65, 0x12, 0x1d, 0x2e, 0x76, 0x69, 0x64, 0x65,
        0x6f, 0x2e, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x73, 0x42, 0x79, 0x44, 0x61, 0x74,
        0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x76, 0x69, 0x64, 0x65, 0x6f,
        0x2e, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x73, 0x42, 0x79, 0x44, 0x61, 0x74, 0x65,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x47, 0x0a, 0x0c, 0x47, 0x65, 0x74, 0x56,
        0x69, 0x64, 0x65, 0x6f, 0x42, 0x79, 0x49, 0x64, 0x12, 0x1a, 0x2e, 0x76, 0x69, 0x64, 0x65, 0x6f,
        0x2e, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x42, 0x79, 0x49, 0x64, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x2e, 0x47, 0x65, 0x74,
        0x56, 0x69, 0x64, 0x65, 0x6f, 0x42, 0x79, 0x49, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x47, 0x0a, 0x0c, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x56, 0x69, 0x64, 0x65, 0x6f,
        0x73, 0x12, 0x1a, 0x2e, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x2e, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68,
        0x56, 0x69, 0x64, 0x65, 0x6f, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e,
        0x76, 0x69, 0x64, 0x65, 0x6f, 0x2e, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x56, 0x69, 0x64, 0x65,
        0x6f, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4a, 0x0a, 0x0d, 0x47, 0x65,
        0x74, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x73, 0x42, 0x79, 0x49, 0x44, 0x12, 0x1b, 0x2e, 0x76, 0x69,
        0x64, 0x65, 0x6f, 0x2e, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x73, 0x42, 0x79, 0x49,
        0x44, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x76, 0x69, 0x64, 0x65, 0x6f,
        0x2e, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x73, 0x42, 0x79, 0x49, 0x44, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x59, 0x0a, 0x12, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64,
        0x65, 0x6f, 0x73, 0x42, 0x79, 0x4b, 0x65, 0x79, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x20, 0x2e, 0x76,
        0x69, 0x64, 0x65, 0x6f, 0x2e, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x73, 0x42, 0x79,
        0x4b, 0x65, 0x79, 0x77, 0x6f, 0x72, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21,
        0x2e, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x2e, 0x47, 0x65, 0x74, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x73,
        0x42, 0x79, 0x4b, 0x65, 0x79, 0x77, 0x6f, 0x72, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x42, 0x2b, 0x5a, 0x29, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
        0x74, 0x69, 0x6b, 0x66, 0x61, 0x63, 0x6b, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x2f, 0x67,
        0x65, 0x6e, 0x2f, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x3b, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x62, 0x06,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
})

var (
        file_video_video_proto_rawDescOnce sync.Once
        file_video_video_proto_rawDescData []byte
)

func file_video_video_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_video_video_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_video_video_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_video_video_proto_rawDesc), len(file_video_video_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_video_video_proto_rawDescData</span>
}

var file_video_video_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_video_video_proto_goTypes = []any{
        (*Actress)(nil),                    // 0: video.Actress
        (*Genre)(nil),                      // 1: video.Genre
        (*Maker)(nil),                      // 2: video.Maker
        (*Series)(nil),                     // 3: video.Series
        (*Director)(nil),                   // 4: video.Director
        (*Review)(nil),                     // 5: video.Review
        (*Video)(nil),                      // 6: video.Video
        (*GetVideosByDateRequest)(nil),     // 7: video.GetVideosByDateRequest
        (*GetVideosByDateResponse)(nil),    // 8: video.GetVideosByDateResponse
        (*GetVideoByIdRequest)(nil),        // 9: video.GetVideoByIdRequest
        (*GetVideoByIdResponse)(nil),       // 10: video.GetVideoByIdResponse
        (*GetVideosByIDRequest)(nil),       // 11: video.GetVideosByIDRequest
        (*GetVideosByKeywordRequest)(nil),  // 12: video.GetVideosByKeywordRequest
        (*GetVideosByIDResponse)(nil),      // 13: video.GetVideosByIDResponse
        (*GetVideosByKeywordResponse)(nil), // 14: video.GetVideosByKeywordResponse
        (*SearchVideosRequest)(nil),        // 15: video.SearchVideosRequest
        (*SearchVideosResponse)(nil),       // 16: video.SearchVideosResponse
}
var file_video_video_proto_depIdxs = []int32{
        0,  // 0: video.Video.actresses:type_name -&gt; video.Actress
        1,  // 1: video.Video.genres:type_name -&gt; video.Genre
        2,  // 2: video.Video.makers:type_name -&gt; video.Maker
        3,  // 3: video.Video.series:type_name -&gt; video.Series
        4,  // 4: video.Video.directors:type_name -&gt; video.Director
        5,  // 5: video.Video.review:type_name -&gt; video.Review
        6,  // 6: video.GetVideosByDateResponse.videos:type_name -&gt; video.Video
        6,  // 7: video.GetVideoByIdResponse.video:type_name -&gt; video.Video
        6,  // 8: video.GetVideosByIDResponse.videos:type_name -&gt; video.Video
        6,  // 9: video.GetVideosByKeywordResponse.videos:type_name -&gt; video.Video
        6,  // 10: video.SearchVideosResponse.videos:type_name -&gt; video.Video
        7,  // 11: video.VideoService.GetVideosByDate:input_type -&gt; video.GetVideosByDateRequest
        9,  // 12: video.VideoService.GetVideoById:input_type -&gt; video.GetVideoByIdRequest
        15, // 13: video.VideoService.SearchVideos:input_type -&gt; video.SearchVideosRequest
        11, // 14: video.VideoService.GetVideosByID:input_type -&gt; video.GetVideosByIDRequest
        12, // 15: video.VideoService.GetVideosByKeyword:input_type -&gt; video.GetVideosByKeywordRequest
        8,  // 16: video.VideoService.GetVideosByDate:output_type -&gt; video.GetVideosByDateResponse
        10, // 17: video.VideoService.GetVideoById:output_type -&gt; video.GetVideoByIdResponse
        16, // 18: video.VideoService.SearchVideos:output_type -&gt; video.SearchVideosResponse
        13, // 19: video.VideoService.GetVideosByID:output_type -&gt; video.GetVideosByIDResponse
        14, // 20: video.VideoService.GetVideosByKeyword:output_type -&gt; video.GetVideosByKeywordResponse
        16, // [16:21] is the sub-list for method output_type
        11, // [11:16] is the sub-list for method input_type
        11, // [11:11] is the sub-list for extension type_name
        11, // [11:11] is the sub-list for extension extendee
        0,  // [0:11] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_video_video_proto_init() }</span>
func file_video_video_proto_init() <span class="cov0" title="0">{
        if File_video_video_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_video_video_proto_rawDesc), len(file_video_video_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   17,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_video_video_proto_goTypes,
                DependencyIndexes: file_video_video_proto_depIdxs,
                MessageInfos:      file_video_video_proto_msgTypes,
        }.Build()
        File_video_video_proto = out.File
        file_video_video_proto_goTypes = nil
        file_video_video_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: video/video.proto

package videoconnect

import (
        context "context"
        errors "errors"
        connect_go "github.com/bufbuild/connect-go"
        video "github.com/tikfack/server/gen/video"
        http "net/http"
        strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect_go.IsAtLeastVersion0_1_0

const (
        // VideoServiceName is the fully-qualified name of the VideoService service.
        VideoServiceName = "video.VideoService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
        // VideoServiceGetVideosByDateProcedure is the fully-qualified name of the VideoService's
        // GetVideosByDate RPC.
        VideoServiceGetVideosByDateProcedure = "/video.VideoService/GetVideosByDate"
        // VideoServiceGetVideoByIdProcedure is the fully-qualified name of the VideoService's GetVideoById
        // RPC.
        VideoServiceGetVideoByIdProcedure = "/video.VideoService/GetVideoById"
        // VideoServiceSearchVideosProcedure is the fully-qualified name of the VideoService's SearchVideos
        // RPC.
        VideoServiceSearchVideosProcedure = "/video.VideoService/SearchVideos"
        // VideoServiceGetVideosByIDProcedure is the fully-qualified name of the VideoService's
        // GetVideosByID RPC.
        VideoServiceGetVideosByIDProcedure = "/video.VideoService/GetVideosByID"
        // VideoServiceGetVideosByKeywordProcedure is the fully-qualified name of the VideoService's
        // GetVideosByKeyword RPC.
        VideoServiceGetVideosByKeywordProcedure = "/video.VideoService/GetVideosByKeyword"
)

// VideoServiceClient is a client for the video.VideoService service.
type VideoServiceClient interface {
        GetVideosByDate(context.Context, *connect_go.Request[video.GetVideosByDateRequest]) (*connect_go.Response[video.GetVideosByDateResponse], error)
        GetVideoById(context.Context, *connect_go.Request[video.GetVideoByIdRequest]) (*connect_go.Response[video.GetVideoByIdResponse], error)
        SearchVideos(context.Context, *connect_go.Request[video.SearchVideosRequest]) (*connect_go.Response[video.SearchVideosResponse], error)
        GetVideosByID(context.Context, *connect_go.Request[video.GetVideosByIDRequest]) (*connect_go.Response[video.GetVideosByIDResponse], error)
        GetVideosByKeyword(context.Context, *connect_go.Request[video.GetVideosByKeywordRequest]) (*connect_go.Response[video.GetVideosByKeywordResponse], error)
}

// NewVideoServiceClient constructs a client for the video.VideoService service. By default, it uses
// the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewVideoServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) VideoServiceClient <span class="cov0" title="0">{
        baseURL = strings.TrimRight(baseURL, "/")
        return &amp;videoServiceClient{
                getVideosByDate: connect_go.NewClient[video.GetVideosByDateRequest, video.GetVideosByDateResponse](
                        httpClient,
                        baseURL+VideoServiceGetVideosByDateProcedure,
                        opts...,
                ),
                getVideoById: connect_go.NewClient[video.GetVideoByIdRequest, video.GetVideoByIdResponse](
                        httpClient,
                        baseURL+VideoServiceGetVideoByIdProcedure,
                        opts...,
                ),
                searchVideos: connect_go.NewClient[video.SearchVideosRequest, video.SearchVideosResponse](
                        httpClient,
                        baseURL+VideoServiceSearchVideosProcedure,
                        opts...,
                ),
                getVideosByID: connect_go.NewClient[video.GetVideosByIDRequest, video.GetVideosByIDResponse](
                        httpClient,
                        baseURL+VideoServiceGetVideosByIDProcedure,
                        opts...,
                ),
                getVideosByKeyword: connect_go.NewClient[video.GetVideosByKeywordRequest, video.GetVideosByKeywordResponse](
                        httpClient,
                        baseURL+VideoServiceGetVideosByKeywordProcedure,
                        opts...,
                ),
        }
}</span>

// videoServiceClient implements VideoServiceClient.
type videoServiceClient struct {
        getVideosByDate    *connect_go.Client[video.GetVideosByDateRequest, video.GetVideosByDateResponse]
        getVideoById       *connect_go.Client[video.GetVideoByIdRequest, video.GetVideoByIdResponse]
        searchVideos       *connect_go.Client[video.SearchVideosRequest, video.SearchVideosResponse]
        getVideosByID      *connect_go.Client[video.GetVideosByIDRequest, video.GetVideosByIDResponse]
        getVideosByKeyword *connect_go.Client[video.GetVideosByKeywordRequest, video.GetVideosByKeywordResponse]
}

// GetVideosByDate calls video.VideoService.GetVideosByDate.
func (c *videoServiceClient) GetVideosByDate(ctx context.Context, req *connect_go.Request[video.GetVideosByDateRequest]) (*connect_go.Response[video.GetVideosByDateResponse], error) <span class="cov0" title="0">{
        return c.getVideosByDate.CallUnary(ctx, req)
}</span>

// GetVideoById calls video.VideoService.GetVideoById.
func (c *videoServiceClient) GetVideoById(ctx context.Context, req *connect_go.Request[video.GetVideoByIdRequest]) (*connect_go.Response[video.GetVideoByIdResponse], error) <span class="cov0" title="0">{
        return c.getVideoById.CallUnary(ctx, req)
}</span>

// SearchVideos calls video.VideoService.SearchVideos.
func (c *videoServiceClient) SearchVideos(ctx context.Context, req *connect_go.Request[video.SearchVideosRequest]) (*connect_go.Response[video.SearchVideosResponse], error) <span class="cov0" title="0">{
        return c.searchVideos.CallUnary(ctx, req)
}</span>

// GetVideosByID calls video.VideoService.GetVideosByID.
func (c *videoServiceClient) GetVideosByID(ctx context.Context, req *connect_go.Request[video.GetVideosByIDRequest]) (*connect_go.Response[video.GetVideosByIDResponse], error) <span class="cov0" title="0">{
        return c.getVideosByID.CallUnary(ctx, req)
}</span>

// GetVideosByKeyword calls video.VideoService.GetVideosByKeyword.
func (c *videoServiceClient) GetVideosByKeyword(ctx context.Context, req *connect_go.Request[video.GetVideosByKeywordRequest]) (*connect_go.Response[video.GetVideosByKeywordResponse], error) <span class="cov0" title="0">{
        return c.getVideosByKeyword.CallUnary(ctx, req)
}</span>

// VideoServiceHandler is an implementation of the video.VideoService service.
type VideoServiceHandler interface {
        GetVideosByDate(context.Context, *connect_go.Request[video.GetVideosByDateRequest]) (*connect_go.Response[video.GetVideosByDateResponse], error)
        GetVideoById(context.Context, *connect_go.Request[video.GetVideoByIdRequest]) (*connect_go.Response[video.GetVideoByIdResponse], error)
        SearchVideos(context.Context, *connect_go.Request[video.SearchVideosRequest]) (*connect_go.Response[video.SearchVideosResponse], error)
        GetVideosByID(context.Context, *connect_go.Request[video.GetVideosByIDRequest]) (*connect_go.Response[video.GetVideosByIDResponse], error)
        GetVideosByKeyword(context.Context, *connect_go.Request[video.GetVideosByKeywordRequest]) (*connect_go.Response[video.GetVideosByKeywordResponse], error)
}

// NewVideoServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewVideoServiceHandler(svc VideoServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) <span class="cov0" title="0">{
        videoServiceGetVideosByDateHandler := connect_go.NewUnaryHandler(
                VideoServiceGetVideosByDateProcedure,
                svc.GetVideosByDate,
                opts...,
        )
        videoServiceGetVideoByIdHandler := connect_go.NewUnaryHandler(
                VideoServiceGetVideoByIdProcedure,
                svc.GetVideoById,
                opts...,
        )
        videoServiceSearchVideosHandler := connect_go.NewUnaryHandler(
                VideoServiceSearchVideosProcedure,
                svc.SearchVideos,
                opts...,
        )
        videoServiceGetVideosByIDHandler := connect_go.NewUnaryHandler(
                VideoServiceGetVideosByIDProcedure,
                svc.GetVideosByID,
                opts...,
        )
        videoServiceGetVideosByKeywordHandler := connect_go.NewUnaryHandler(
                VideoServiceGetVideosByKeywordProcedure,
                svc.GetVideosByKeyword,
                opts...,
        )
        return "/video.VideoService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                switch r.URL.Path </span>{
                case VideoServiceGetVideosByDateProcedure:<span class="cov0" title="0">
                        videoServiceGetVideosByDateHandler.ServeHTTP(w, r)</span>
                case VideoServiceGetVideoByIdProcedure:<span class="cov0" title="0">
                        videoServiceGetVideoByIdHandler.ServeHTTP(w, r)</span>
                case VideoServiceSearchVideosProcedure:<span class="cov0" title="0">
                        videoServiceSearchVideosHandler.ServeHTTP(w, r)</span>
                case VideoServiceGetVideosByIDProcedure:<span class="cov0" title="0">
                        videoServiceGetVideosByIDHandler.ServeHTTP(w, r)</span>
                case VideoServiceGetVideosByKeywordProcedure:<span class="cov0" title="0">
                        videoServiceGetVideosByKeywordHandler.ServeHTTP(w, r)</span>
                default:<span class="cov0" title="0">
                        http.NotFound(w, r)</span>
                }
        })
}

// UnimplementedVideoServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedVideoServiceHandler struct{}

func (UnimplementedVideoServiceHandler) GetVideosByDate(context.Context, *connect_go.Request[video.GetVideosByDateRequest]) (*connect_go.Response[video.GetVideosByDateResponse], error) <span class="cov0" title="0">{
        return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("video.VideoService.GetVideosByDate is not implemented"))
}</span>

func (UnimplementedVideoServiceHandler) GetVideoById(context.Context, *connect_go.Request[video.GetVideoByIdRequest]) (*connect_go.Response[video.GetVideoByIdResponse], error) <span class="cov0" title="0">{
        return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("video.VideoService.GetVideoById is not implemented"))
}</span>

func (UnimplementedVideoServiceHandler) SearchVideos(context.Context, *connect_go.Request[video.SearchVideosRequest]) (*connect_go.Response[video.SearchVideosResponse], error) <span class="cov0" title="0">{
        return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("video.VideoService.SearchVideos is not implemented"))
}</span>

func (UnimplementedVideoServiceHandler) GetVideosByID(context.Context, *connect_go.Request[video.GetVideosByIDRequest]) (*connect_go.Response[video.GetVideosByIDResponse], error) <span class="cov0" title="0">{
        return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("video.VideoService.GetVideosByID is not implemented"))
}</span>

func (UnimplementedVideoServiceHandler) GetVideosByKeyword(context.Context, *connect_go.Request[video.GetVideosByKeywordRequest]) (*connect_go.Response[video.GetVideosByKeywordResponse], error) <span class="cov0" title="0">{
        return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("video.VideoService.GetVideosByKeyword is not implemented"))
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/tikfack/server/internal/application/usecase/video (interfaces: VideoUsecase)
//
// Generated by this command:
//
//        mockgen -destination=../mock/mock_video_usecase.go -package=mock github.com/tikfack/server/internal/application/usecase/video VideoUsecase
//

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"
        time "time"

        entity "github.com/tikfack/server/internal/domain/entity"
        gomock "go.uber.org/mock/gomock"
)

// MockVideoUsecase is a mock of VideoUsecase interface.
type MockVideoUsecase struct {
        ctrl     *gomock.Controller
        recorder *MockVideoUsecaseMockRecorder
        isgomock struct{}
}

// MockVideoUsecaseMockRecorder is the mock recorder for MockVideoUsecase.
type MockVideoUsecaseMockRecorder struct {
        mock *MockVideoUsecase
}

// NewMockVideoUsecase creates a new mock instance.
func NewMockVideoUsecase(ctrl *gomock.Controller) *MockVideoUsecase <span class="cov0" title="0">{
        mock := &amp;MockVideoUsecase{ctrl: ctrl}
        mock.recorder = &amp;MockVideoUsecaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockVideoUsecase) EXPECT() *MockVideoUsecaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetVideoById mocks base method.
func (m *MockVideoUsecase) GetVideoById(ctx context.Context, dmmId string) (*entity.Video, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVideoById", ctx, dmmId)
        ret0, _ := ret[0].(*entity.Video)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVideoById indicates an expected call of GetVideoById.
func (mr *MockVideoUsecaseMockRecorder) GetVideoById(ctx, dmmId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVideoById", reflect.TypeOf((*MockVideoUsecase)(nil).GetVideoById), ctx, dmmId)
}</span>

// GetVideosByDate mocks base method.
func (m *MockVideoUsecase) GetVideosByDate(ctx context.Context, targetDate time.Time) ([]entity.Video, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVideosByDate", ctx, targetDate)
        ret0, _ := ret[0].([]entity.Video)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVideosByDate indicates an expected call of GetVideosByDate.
func (mr *MockVideoUsecaseMockRecorder) GetVideosByDate(ctx, targetDate any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVideosByDate", reflect.TypeOf((*MockVideoUsecase)(nil).GetVideosByDate), ctx, targetDate)
}</span>

// GetVideosByID mocks base method.
func (m *MockVideoUsecase) GetVideosByID(ctx context.Context, actressIDs, genreIDs, makerIDs, seriesIDs, directorIDs []string, hits, offset int32, sort, gteDate, lteDate, site, service, floor string) ([]entity.Video, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVideosByID", ctx, actressIDs, genreIDs, makerIDs, seriesIDs, directorIDs, hits, offset, sort, gteDate, lteDate, site, service, floor)
        ret0, _ := ret[0].([]entity.Video)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVideosByID indicates an expected call of GetVideosByID.
func (mr *MockVideoUsecaseMockRecorder) GetVideosByID(ctx, actressIDs, genreIDs, makerIDs, seriesIDs, directorIDs, hits, offset, sort, gteDate, lteDate, site, service, floor any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVideosByID", reflect.TypeOf((*MockVideoUsecase)(nil).GetVideosByID), ctx, actressIDs, genreIDs, makerIDs, seriesIDs, directorIDs, hits, offset, sort, gteDate, lteDate, site, service, floor)
}</span>

// GetVideosByKeyword mocks base method.
func (m *MockVideoUsecase) GetVideosByKeyword(ctx context.Context, keyword string, hits, offset int32, sort, gteDate, lteDate, site, service, floor string) ([]entity.Video, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVideosByKeyword", ctx, keyword, hits, offset, sort, gteDate, lteDate, site, service, floor)
        ret0, _ := ret[0].([]entity.Video)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVideosByKeyword indicates an expected call of GetVideosByKeyword.
func (mr *MockVideoUsecaseMockRecorder) GetVideosByKeyword(ctx, keyword, hits, offset, sort, gteDate, lteDate, site, service, floor any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVideosByKeyword", reflect.TypeOf((*MockVideoUsecase)(nil).GetVideosByKeyword), ctx, keyword, hits, offset, sort, gteDate, lteDate, site, service, floor)
}</span>

// SearchVideos mocks base method.
func (m *MockVideoUsecase) SearchVideos(ctx context.Context, keyword, actressID, genreID, makerID, seriesID, directorID string) ([]entity.Video, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchVideos", ctx, keyword, actressID, genreID, makerID, seriesID, directorID)
        ret0, _ := ret[0].([]entity.Video)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SearchVideos indicates an expected call of SearchVideos.
func (mr *MockVideoUsecaseMockRecorder) SearchVideos(ctx, keyword, actressID, genreID, makerID, seriesID, directorID any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchVideos", reflect.TypeOf((*MockVideoUsecase)(nil).SearchVideos), ctx, keyword, actressID, genreID, makerID, seriesID, directorID)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package usecase

//go:generate mockgen -destination=../mock/mock_video_usecase.go -package=mock github.com/tikfack/server/internal/application/usecase/video VideoUsecase

import (
        "context"
        "log/slog"
        "time"

        "github.com/tikfack/server/internal/domain/entity"
        "github.com/tikfack/server/internal/domain/repository"
)

// VideoUsecase は動画関連のユースケースを定義するインターフェイス
type VideoUsecase interface {
        GetVideosByDate(ctx context.Context, targetDate time.Time) ([]entity.Video, error)
        GetVideoById(ctx context.Context, dmmId string) (*entity.Video, error)
        SearchVideos(ctx context.Context, keyword, actressID, genreID, makerID, seriesID, directorID string) ([]entity.Video, error)
        GetVideosByID(ctx context.Context, actressIDs, genreIDs, makerIDs, seriesIDs, directorIDs []string, hits int32, offset int32, sort string, gteDate string, lteDate string, site string, service string, floor string) ([]entity.Video, error)
        GetVideosByKeyword(ctx context.Context, keyword string, hits int32, offset int32, sort string, gteDate string, lteDate string, site string, service string, floor string) ([]entity.Video, error)
}

// videoUsecase は VideoUsecase の実装
type videoUsecase struct {
        videoRepo repository.VideoRepository
        logger    *slog.Logger
}

// NewVideoUsecase は依存する VideoRepository を受け取り VideoUsecase を返す
func NewVideoUsecase(repo repository.VideoRepository) VideoUsecase <span class="cov8" title="1">{
        return &amp;videoUsecase{
                videoRepo: repo,
                logger:    slog.Default().With(slog.String("component", "video_usecase")),
        }
}</span>

// GetVideosByDate は指定日付の動画一覧を取得する
func (u *videoUsecase) GetVideosByDate(ctx context.Context, targetDate time.Time) ([]entity.Video, error) <span class="cov8" title="1">{
        u.logger.Debug("GetVideosByDate called", "targetDate", targetDate.Format("2006-01-02"))
        return u.videoRepo.GetVideosByDate(ctx, targetDate)
}</span>

// GetVideoById は、指定された DMMビデオID の動画を取得する
func (u *videoUsecase) GetVideoById(ctx context.Context, dmmId string) (*entity.Video, error) <span class="cov8" title="1">{
        u.logger.Debug("GetVideoById called", "dmmId", dmmId)
        return u.videoRepo.GetVideoById(ctx, dmmId)
}</span>

// SearchVideos は動画をキーワードや各種IDで検索する
func (u *videoUsecase) SearchVideos(ctx context.Context, keyword, actressID, genreID, makerID, seriesID, directorID string) ([]entity.Video, error) <span class="cov8" title="1">{
        u.logger.Debug("SearchVideos called", 
                "keyword", keyword,
                "actressID", actressID,
                "genreID", genreID,
                "makerID", makerID,
                "seriesID", seriesID,
                "directorID", directorID)
        return u.videoRepo.SearchVideos(ctx, keyword, actressID, genreID, makerID, seriesID, directorID)
}</span>

// GetVideosByID は複数のIDを使用して動画を検索する
func (u *videoUsecase) GetVideosByID(ctx context.Context, actressIDs, genreIDs, makerIDs, seriesIDs, directorIDs []string, hits int32, offset int32, sort string, gteDate string, lteDate string, site string, service string, floor string) ([]entity.Video, error) <span class="cov8" title="1">{
        u.logger.Debug("GetVideosByID called", 
                "actressIDs_count", len(actressIDs),
                "genreIDs_count", len(genreIDs),
                "makerIDs_count", len(makerIDs),
                "seriesIDs_count", len(seriesIDs),
                "directorIDs_count", len(directorIDs),
                "hits", hits,
                "offset", offset,
                "sort", sort)
        return u.videoRepo.GetVideosByID(ctx, actressIDs, genreIDs, makerIDs, seriesIDs, directorIDs, hits, offset, sort, gteDate, lteDate, site, service, floor)
}</span>

// GetVideosByKeyword はキーワードを使用して動画を検索する
func (u *videoUsecase) GetVideosByKeyword(ctx context.Context, keyword string, hits int32, offset int32, sort string, gteDate string, lteDate string, site string, service string, floor string) ([]entity.Video, error) <span class="cov8" title="1">{
        u.logger.Debug("GetVideosByKeyword called", 
                "keyword", keyword,
                "hits", hits,
                "offset", offset,
                "sort", sort,
                "gteDate", gteDate,
                "lteDate", lteDate)
        return u.videoRepo.GetVideosByKeyword(ctx, keyword, hits, offset, sort, gteDate, lteDate, site, service, floor)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/tikfack/server/internal/domain/repository (interfaces: VideoRepository)

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"
        time "time"

        "go.uber.org/mock/gomock"
        entity "github.com/tikfack/server/internal/domain/entity"
)

// MockVideoRepository is a mock of VideoRepository interface.
type MockVideoRepository struct {
        ctrl     *gomock.Controller
        recorder *MockVideoRepositoryMockRecorder
}

// MockVideoRepositoryMockRecorder is the mock recorder for MockVideoRepository.
type MockVideoRepositoryMockRecorder struct {
        mock *MockVideoRepository
}

// NewMockVideoRepository creates a new mock instance.
func NewMockVideoRepository(ctrl *gomock.Controller) *MockVideoRepository <span class="cov0" title="0">{
        mock := &amp;MockVideoRepository{ctrl: ctrl}
        mock.recorder = &amp;MockVideoRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockVideoRepository) EXPECT() *MockVideoRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetVideoById mocks base method.
func (m *MockVideoRepository) GetVideoById(arg0 context.Context, arg1 string) (*entity.Video, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVideoById", arg0, arg1)
        ret0, _ := ret[0].(*entity.Video)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVideoById indicates an expected call of GetVideoById.
func (mr *MockVideoRepositoryMockRecorder) GetVideoById(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVideoById", reflect.TypeOf((*MockVideoRepository)(nil).GetVideoById), arg0, arg1)
}</span>

// GetVideosByDate mocks base method.
func (m *MockVideoRepository) GetVideosByDate(arg0 context.Context, arg1 time.Time) ([]entity.Video, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVideosByDate", arg0, arg1)
        ret0, _ := ret[0].([]entity.Video)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVideosByDate indicates an expected call of GetVideosByDate.
func (mr *MockVideoRepositoryMockRecorder) GetVideosByDate(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVideosByDate", reflect.TypeOf((*MockVideoRepository)(nil).GetVideosByDate), arg0, arg1)
}</span>

// GetVideosByID mocks base method.
func (m *MockVideoRepository) GetVideosByID(arg0 context.Context, arg1, arg2, arg3, arg4, arg5 []string, arg6, arg7 int32, arg8, arg9, arg10, arg11, arg12, arg13 string) ([]entity.Video, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVideosByID", arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)
        ret0, _ := ret[0].([]entity.Video)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVideosByID indicates an expected call of GetVideosByID.
func (mr *MockVideoRepositoryMockRecorder) GetVideosByID(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVideosByID", reflect.TypeOf((*MockVideoRepository)(nil).GetVideosByID), arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)
}</span>

// GetVideosByKeyword mocks base method.
func (m *MockVideoRepository) GetVideosByKeyword(arg0 context.Context, arg1 string, arg2, arg3 int32, arg4, arg5, arg6, arg7, arg8, arg9 string) ([]entity.Video, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVideosByKeyword", arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
        ret0, _ := ret[0].([]entity.Video)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVideosByKeyword indicates an expected call of GetVideosByKeyword.
func (mr *MockVideoRepositoryMockRecorder) GetVideosByKeyword(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVideosByKeyword", reflect.TypeOf((*MockVideoRepository)(nil).GetVideosByKeyword), arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
}</span>

// SearchVideos mocks base method.
func (m *MockVideoRepository) SearchVideos(arg0 context.Context, arg1, arg2, arg3, arg4, arg5, arg6 string) ([]entity.Video, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchVideos", arg0, arg1, arg2, arg3, arg4, arg5, arg6)
        ret0, _ := ret[0].([]entity.Video)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SearchVideos indicates an expected call of SearchVideos.
func (mr *MockVideoRepositoryMockRecorder) SearchVideos(arg0, arg1, arg2, arg3, arg4, arg5, arg6 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchVideos", reflect.TypeOf((*MockVideoRepository)(nil).SearchVideos), arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: gen/video/videoconnect/video.connect.go
//
// Generated by this command:
//
//        mockgen -source=gen/video/videoconnect/video.connect.go -destination=internal/infrastructure/connect/mock/mock_video_service_server.go -package=mock
//

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"

        connect "github.com/bufbuild/connect-go"
        video "github.com/tikfack/server/gen/video"
        gomock "go.uber.org/mock/gomock"
)

// MockVideoServiceClient is a mock of VideoServiceClient interface.
type MockVideoServiceClient struct {
        ctrl     *gomock.Controller
        recorder *MockVideoServiceClientMockRecorder
        isgomock struct{}
}

// MockVideoServiceClientMockRecorder is the mock recorder for MockVideoServiceClient.
type MockVideoServiceClientMockRecorder struct {
        mock *MockVideoServiceClient
}

// NewMockVideoServiceClient creates a new mock instance.
func NewMockVideoServiceClient(ctrl *gomock.Controller) *MockVideoServiceClient <span class="cov0" title="0">{
        mock := &amp;MockVideoServiceClient{ctrl: ctrl}
        mock.recorder = &amp;MockVideoServiceClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockVideoServiceClient) EXPECT() *MockVideoServiceClientMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetVideoById mocks base method.
func (m *MockVideoServiceClient) GetVideoById(arg0 context.Context, arg1 *connect.Request[video.GetVideoByIdRequest]) (*connect.Response[video.GetVideoByIdResponse], error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVideoById", arg0, arg1)
        ret0, _ := ret[0].(*connect.Response[video.GetVideoByIdResponse])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVideoById indicates an expected call of GetVideoById.
func (mr *MockVideoServiceClientMockRecorder) GetVideoById(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVideoById", reflect.TypeOf((*MockVideoServiceClient)(nil).GetVideoById), arg0, arg1)
}</span>

// GetVideosByDate mocks base method.
func (m *MockVideoServiceClient) GetVideosByDate(arg0 context.Context, arg1 *connect.Request[video.GetVideosByDateRequest]) (*connect.Response[video.GetVideosByDateResponse], error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVideosByDate", arg0, arg1)
        ret0, _ := ret[0].(*connect.Response[video.GetVideosByDateResponse])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVideosByDate indicates an expected call of GetVideosByDate.
func (mr *MockVideoServiceClientMockRecorder) GetVideosByDate(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVideosByDate", reflect.TypeOf((*MockVideoServiceClient)(nil).GetVideosByDate), arg0, arg1)
}</span>

// GetVideosByID mocks base method.
func (m *MockVideoServiceClient) GetVideosByID(arg0 context.Context, arg1 *connect.Request[video.GetVideosByIDRequest]) (*connect.Response[video.GetVideosByIDResponse], error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVideosByID", arg0, arg1)
        ret0, _ := ret[0].(*connect.Response[video.GetVideosByIDResponse])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVideosByID indicates an expected call of GetVideosByID.
func (mr *MockVideoServiceClientMockRecorder) GetVideosByID(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVideosByID", reflect.TypeOf((*MockVideoServiceClient)(nil).GetVideosByID), arg0, arg1)
}</span>

// GetVideosByKeyword mocks base method.
func (m *MockVideoServiceClient) GetVideosByKeyword(arg0 context.Context, arg1 *connect.Request[video.GetVideosByKeywordRequest]) (*connect.Response[video.GetVideosByKeywordResponse], error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVideosByKeyword", arg0, arg1)
        ret0, _ := ret[0].(*connect.Response[video.GetVideosByKeywordResponse])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVideosByKeyword indicates an expected call of GetVideosByKeyword.
func (mr *MockVideoServiceClientMockRecorder) GetVideosByKeyword(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVideosByKeyword", reflect.TypeOf((*MockVideoServiceClient)(nil).GetVideosByKeyword), arg0, arg1)
}</span>

// SearchVideos mocks base method.
func (m *MockVideoServiceClient) SearchVideos(arg0 context.Context, arg1 *connect.Request[video.SearchVideosRequest]) (*connect.Response[video.SearchVideosResponse], error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchVideos", arg0, arg1)
        ret0, _ := ret[0].(*connect.Response[video.SearchVideosResponse])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SearchVideos indicates an expected call of SearchVideos.
func (mr *MockVideoServiceClientMockRecorder) SearchVideos(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchVideos", reflect.TypeOf((*MockVideoServiceClient)(nil).SearchVideos), arg0, arg1)
}</span>

// MockVideoServiceHandler is a mock of VideoServiceHandler interface.
type MockVideoServiceHandler struct {
        ctrl     *gomock.Controller
        recorder *MockVideoServiceHandlerMockRecorder
        isgomock struct{}
}

// MockVideoServiceHandlerMockRecorder is the mock recorder for MockVideoServiceHandler.
type MockVideoServiceHandlerMockRecorder struct {
        mock *MockVideoServiceHandler
}

// NewMockVideoServiceHandler creates a new mock instance.
func NewMockVideoServiceHandler(ctrl *gomock.Controller) *MockVideoServiceHandler <span class="cov0" title="0">{
        mock := &amp;MockVideoServiceHandler{ctrl: ctrl}
        mock.recorder = &amp;MockVideoServiceHandlerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockVideoServiceHandler) EXPECT() *MockVideoServiceHandlerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetVideoById mocks base method.
func (m *MockVideoServiceHandler) GetVideoById(arg0 context.Context, arg1 *connect.Request[video.GetVideoByIdRequest]) (*connect.Response[video.GetVideoByIdResponse], error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVideoById", arg0, arg1)
        ret0, _ := ret[0].(*connect.Response[video.GetVideoByIdResponse])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVideoById indicates an expected call of GetVideoById.
func (mr *MockVideoServiceHandlerMockRecorder) GetVideoById(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVideoById", reflect.TypeOf((*MockVideoServiceHandler)(nil).GetVideoById), arg0, arg1)
}</span>

// GetVideosByDate mocks base method.
func (m *MockVideoServiceHandler) GetVideosByDate(arg0 context.Context, arg1 *connect.Request[video.GetVideosByDateRequest]) (*connect.Response[video.GetVideosByDateResponse], error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVideosByDate", arg0, arg1)
        ret0, _ := ret[0].(*connect.Response[video.GetVideosByDateResponse])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVideosByDate indicates an expected call of GetVideosByDate.
func (mr *MockVideoServiceHandlerMockRecorder) GetVideosByDate(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVideosByDate", reflect.TypeOf((*MockVideoServiceHandler)(nil).GetVideosByDate), arg0, arg1)
}</span>

// GetVideosByID mocks base method.
func (m *MockVideoServiceHandler) GetVideosByID(arg0 context.Context, arg1 *connect.Request[video.GetVideosByIDRequest]) (*connect.Response[video.GetVideosByIDResponse], error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVideosByID", arg0, arg1)
        ret0, _ := ret[0].(*connect.Response[video.GetVideosByIDResponse])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVideosByID indicates an expected call of GetVideosByID.
func (mr *MockVideoServiceHandlerMockRecorder) GetVideosByID(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVideosByID", reflect.TypeOf((*MockVideoServiceHandler)(nil).GetVideosByID), arg0, arg1)
}</span>

// GetVideosByKeyword mocks base method.
func (m *MockVideoServiceHandler) GetVideosByKeyword(arg0 context.Context, arg1 *connect.Request[video.GetVideosByKeywordRequest]) (*connect.Response[video.GetVideosByKeywordResponse], error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVideosByKeyword", arg0, arg1)
        ret0, _ := ret[0].(*connect.Response[video.GetVideosByKeywordResponse])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVideosByKeyword indicates an expected call of GetVideosByKeyword.
func (mr *MockVideoServiceHandlerMockRecorder) GetVideosByKeyword(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVideosByKeyword", reflect.TypeOf((*MockVideoServiceHandler)(nil).GetVideosByKeyword), arg0, arg1)
}</span>

// SearchVideos mocks base method.
func (m *MockVideoServiceHandler) SearchVideos(arg0 context.Context, arg1 *connect.Request[video.SearchVideosRequest]) (*connect.Response[video.SearchVideosResponse], error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchVideos", arg0, arg1)
        ret0, _ := ret[0].(*connect.Response[video.SearchVideosResponse])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SearchVideos indicates an expected call of SearchVideos.
func (mr *MockVideoServiceHandlerMockRecorder) SearchVideos(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchVideos", reflect.TypeOf((*MockVideoServiceHandler)(nil).SearchVideos), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package connect

import (
        "context"
        "log/slog"
        "net/http"
        "time"

        "github.com/bufbuild/connect-go"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        pb "github.com/tikfack/server/gen/video" // ※生成コードのパッケージ名に合わせて調整してください
        videoconnect "github.com/tikfack/server/gen/video/videoconnect"

        video "github.com/tikfack/server/internal/application/usecase/video"
        "github.com/tikfack/server/internal/domain/entity"
        "github.com/tikfack/server/internal/infrastructure/repository"
        "github.com/tikfack/server/internal/infrastructure/util"
)

// videoServiceServer は Connect のサーバー実装です。
type videoServiceServer struct {
        videoUsecase video.VideoUsecase
        logger       *slog.Logger
}

// NewVideoServiceHandler はハンドラーの初期化を行います。
func NewVideoServiceHandler() *videoServiceServer <span class="cov8" title="1">{
        // repository.NewDMMVideoRepository() の実装を渡す
        repo, err := repository.NewVideoRepository()
        if err != nil </span><span class="cov0" title="0">{
                // TODO: Consider how to handle initialization error
                panic(err)</span>
        }
        <span class="cov8" title="1">vu := video.NewVideoUsecase(repo)
        return &amp;videoServiceServer{
                videoUsecase: vu,
                logger:       slog.Default().With(slog.String("component", "video_handler")),
        }</span>
}

func NewVideoServiceHandlerWithUsecase(vu video.VideoUsecase) *videoServiceServer <span class="cov8" title="1">{
        return &amp;videoServiceServer{
                videoUsecase: vu,
                logger:       slog.Default().With(slog.String("component", "video_handler")),
        }
}</span>

// GetHandler は、Connect サービスのパターンとハンドラーを返します。
func (s *videoServiceServer) GetHandler() (string, http.Handler) <span class="cov8" title="1">{
        // 生成されたコードの関数名に合わせてください
        // 例: pb.NewVideoServiceHandler または v1connect.NewVideoServiceHandler
        pattern, handler := videoconnect.NewVideoServiceHandler(s, connect.WithCompressMinBytes(0))
        return pattern, handler
}</span>

// GetVideosByDate は、動画一覧を取得するエンドポイントの実装例です。
func (s *videoServiceServer) GetVideosByDate(ctx context.Context, req *connect.Request[pb.GetVideosByDateRequest]) (*connect.Response[pb.GetVideosByDateResponse], error) <span class="cov8" title="1">{
        s.logger.Debug("API: GetVideosByDate", "date", req.Msg.Date)
        
        var targetDate time.Time
        if req.Msg.Date == "" </span><span class="cov8" title="1">{
                targetDate = time.Now()
        }</span> else<span class="cov8" title="1"> {
                t, err := time.Parse("2006-01-02", req.Msg.Date)
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Error("不正な日付形式", "date", req.Msg.Date, "error", err)
                        return nil, status.Error(codes.InvalidArgument, "不正な日付形式です")
                }</span>
                <span class="cov8" title="1">targetDate = t</span>
        }
        
        // ユースケースから動画リストを取得
        <span class="cov8" title="1">videos, err := s.videoUsecase.GetVideosByDate(ctx, targetDate)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("動画の取得に失敗", "date", targetDate.Format("2006-01-02"), "error", err)
                return nil, status.Errorf(codes.Internal, "動画の取得に失敗しました: %v", err)
        }</span>
        
        // ハンドラー層で各動画のURL検証を行う
        <span class="cov8" title="1">for i := range videos </span><span class="cov8" title="1">{
                directURL, err := util.GetValidVideoUrl(videos[i].DmmID)
                if err == nil </span><span class="cov0" title="0">{
                        videos[i].DirectURL = directURL
                }</span>
        }
        
        <span class="cov8" title="1">pbVideos := convertVideosToPb(videos)
        s.logger.Debug("GetVideosByDate completed", "count", len(pbVideos))
        res := &amp;pb.GetVideosByDateResponse{Videos: pbVideos}
        return connect.NewResponse(res), nil</span>
}

// GetVideoById は、ID で動画を取得するエンドポイントの実装例です。
func (s *videoServiceServer) GetVideoById(ctx context.Context, req *connect.Request[pb.GetVideoByIdRequest]) (*connect.Response[pb.GetVideoByIdResponse], error) <span class="cov8" title="1">{
        s.logger.Debug("API: GetVideoById", "dmmId", req.Msg.DmmId)
        
        video, err := s.videoUsecase.GetVideoById(ctx, req.Msg.DmmId)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("動画の取得に失敗", "dmmId", req.Msg.DmmId, "error", err)
                return nil, status.Errorf(codes.Internal, "動画の取得に失敗しました: %v", err)
        }</span>
        <span class="cov8" title="1">if video == nil </span><span class="cov0" title="0">{
                s.logger.Info("動画が見つかりません", "dmmId", req.Msg.DmmId)
                return nil, status.Error(codes.NotFound, "video not found")
        }</span>
        
        // ハンドラー層でURL検証を行う
        <span class="cov8" title="1">directURL, err := util.GetValidVideoUrl(video.DmmID)
        if err == nil </span><span class="cov0" title="0">{
                video.DirectURL = directURL
        }</span>
        
        <span class="cov8" title="1">s.logger.Debug("GetVideoById completed", "dmmId", req.Msg.DmmId, "title", video.Title)
        res := &amp;pb.GetVideoByIdResponse{Video: convertToPbVideo(*video)}
        return connect.NewResponse(res), nil</span>
}

// SearchVideos は、動画を検索するエンドポイントの実装です。
func (s *videoServiceServer) SearchVideos(ctx context.Context, req *connect.Request[pb.SearchVideosRequest]) (*connect.Response[pb.SearchVideosResponse], error) <span class="cov8" title="1">{
        s.logger.Debug("API: SearchVideos", 
                "keyword", req.Msg.Keyword, 
                "actressId", req.Msg.ActressId, 
                "genreId", req.Msg.GenreId, 
                "makerId", req.Msg.MakerId,
                "seriesId", req.Msg.SeriesId,
                "directorId", req.Msg.DirectorId)
        
        // 実装が完了したら、こちらでもURL検証を行うように修正
        videos, err := s.videoUsecase.SearchVideos(ctx, 
                req.Msg.Keyword, 
                req.Msg.ActressId, 
                req.Msg.GenreId, 
                req.Msg.MakerId, 
                req.Msg.SeriesId, 
                req.Msg.DirectorId)
        
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("動画の検索に失敗", "keyword", req.Msg.Keyword, "error", err)
                return nil, status.Errorf(codes.Internal, "動画の検索に失敗しました: %v", err)
        }</span>
        
        // ハンドラー層で各動画のURL検証を行う
        <span class="cov8" title="1">for i := range videos </span><span class="cov8" title="1">{
                directURL, err := util.GetValidVideoUrl(videos[i].DmmID)
                if err == nil </span><span class="cov0" title="0">{
                        videos[i].DirectURL = directURL
                }</span>
        }
        
        <span class="cov8" title="1">pbVideos := convertVideosToPb(videos)
        s.logger.Debug("SearchVideos completed", "count", len(pbVideos))
        return connect.NewResponse(&amp;pb.SearchVideosResponse{
                Videos: pbVideos,
        }), nil</span>
}

// GetVideosByID は、複数のIDで動画を検索するエンドポイントの実装です。
func (s *videoServiceServer) GetVideosByID(ctx context.Context, req *connect.Request[pb.GetVideosByIDRequest]) (*connect.Response[pb.GetVideosByIDResponse], error) <span class="cov8" title="1">{
        s.logger.Debug("API: GetVideosByID", 
                "actressId_count", len(req.Msg.ActressId),
                "genreId_count", len(req.Msg.GenreId),
                "makerId_count", len(req.Msg.MakerId),
                "seriesId_count", len(req.Msg.SeriesId),
                "directorId_count", len(req.Msg.DirectorId),
                "hits", req.Msg.Hits,
                "offset", req.Msg.Offset)
        
        videos, err := s.videoUsecase.GetVideosByID(ctx, 
                req.Msg.ActressId, 
                req.Msg.GenreId, 
                req.Msg.MakerId, 
                req.Msg.SeriesId, 
                req.Msg.DirectorId,
                req.Msg.Hits,
                req.Msg.Offset,
                req.Msg.Sort,
                req.Msg.GteDate,
                req.Msg.LteDate,
                req.Msg.Site,
                req.Msg.Service,
                req.Msg.Floor)

        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("動画の検索に失敗", "error", err)
                return nil, status.Errorf(codes.Internal, "動画の検索に失敗しました: %v", err)
        }</span>
        
        // ハンドラー層で各動画のURL検証を行う
        <span class="cov8" title="1">for i := range videos </span><span class="cov8" title="1">{
                directURL, err := util.GetValidVideoUrl(videos[i].DmmID)
                if err == nil </span><span class="cov0" title="0">{
                        videos[i].DirectURL = directURL
                }</span>
        }
        
        <span class="cov8" title="1">pbVideos := convertVideosToPb(videos)
        s.logger.Debug("GetVideosByID completed", "count", len(pbVideos))
        return connect.NewResponse(&amp;pb.GetVideosByIDResponse{
                Videos: pbVideos,
        }), nil</span>
}

// GetVideosByKeyword は、キーワードで動画を検索するエンドポイントの実装です。
func (s *videoServiceServer) GetVideosByKeyword(ctx context.Context, req *connect.Request[pb.GetVideosByKeywordRequest]) (*connect.Response[pb.GetVideosByKeywordResponse], error) <span class="cov8" title="1">{
        s.logger.Debug("API: GetVideosByKeyword", 
                "keyword", req.Msg.Keyword,
                "hits", req.Msg.Hits,
                "offset", req.Msg.Offset,
                "sort", req.Msg.Sort)
        
        videos, err := s.videoUsecase.GetVideosByKeyword(ctx, 
                req.Msg.Keyword,
                req.Msg.Hits,
                req.Msg.Offset,
                req.Msg.Sort,
                req.Msg.GteDate,
                req.Msg.LteDate,
                req.Msg.Site,
                req.Msg.Service,
                req.Msg.Floor)
        
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("動画の検索に失敗", "keyword", req.Msg.Keyword, "error", err)
                return nil, status.Errorf(codes.Internal, "動画の検索に失敗しました: %v", err)
        }</span>
        
        // ハンドラー層で各動画のURL検証を行う
        <span class="cov8" title="1">for i := range videos </span><span class="cov8" title="1">{
                directURL, err := util.GetValidVideoUrl(videos[i].DmmID)
                if err == nil </span><span class="cov0" title="0">{
                        videos[i].DirectURL = directURL
                }</span>
        }
        
        <span class="cov8" title="1">pbVideos := convertVideosToPb(videos)
        s.logger.Debug("GetVideosByKeyword completed", "count", len(pbVideos))
        return connect.NewResponse(&amp;pb.GetVideosByKeywordResponse{
                Videos: pbVideos,
        }), nil</span>
}

// convertVideosToPb はドメイン層の Video を pb.Video に変換します。
func convertVideosToPb(videos []entity.Video) []*pb.Video <span class="cov8" title="1">{
        var pbVideos []*pb.Video
        for _, v := range videos </span><span class="cov8" title="1">{
                pbVideos = append(pbVideos, convertToPbVideo(v))
        }</span>
        <span class="cov8" title="1">return pbVideos</span>
}

// convertToPbVideo は、ドメイン層の Video を pb.Video に変換するヘルパーです。
func convertToPbVideo(v entity.Video) *pb.Video <span class="cov8" title="1">{
        pbVideo := &amp;pb.Video{
                DmmId:        v.DmmID,
                Title:        v.Title,
                DirectUrl:    v.DirectURL,
                Url:          v.URL,
                SampleUrl:    v.SampleURL,
                ThumbnailUrl: v.ThumbnailURL,
                CreatedAt:    v.CreatedAt.Format("2006-01-02 15:04:05"),
                LikesCount:   int32(v.LikesCount),
                Price:        int32(v.Price),
                // Author情報はProtobufモデルに存在しないため削除
                // 代わりに女優リストを使用
                Actresses:    convertActressesToPb(v.Actresses),
                Genres:       convertGenresToPb(v.Genres),
                Makers:       convertMakersToPb(v.Makers),
                Series:       convertSeriesToPb(v.Series),
                Directors:    convertDirectorsToPb(v.Directors),
                Review:       convertReviewToPb(v.Review),
        }
        
        // プロトコルバッファオブジェクトをJSON形式でログに出
        
        return pbVideo
}</span>

// 各エンティティの変換関数
func convertActressesToPb(actresses []entity.Actress) []*pb.Actress <span class="cov8" title="1">{
        var result []*pb.Actress
        for _, a := range actresses </span><span class="cov8" title="1">{
                result = append(result, &amp;pb.Actress{
                        Id:   a.ID,
                        Name: a.Name,
                })
        }</span>
        <span class="cov8" title="1">return result</span>
}

func convertGenresToPb(genres []entity.Genre) []*pb.Genre <span class="cov8" title="1">{
        var result []*pb.Genre
        for _, g := range genres </span><span class="cov8" title="1">{
                result = append(result, &amp;pb.Genre{
                        Id:   g.ID,
                        Name: g.Name,
                })
        }</span>
        <span class="cov8" title="1">return result</span>
}

func convertMakersToPb(makers []entity.Maker) []*pb.Maker <span class="cov8" title="1">{
        var result []*pb.Maker
        for _, m := range makers </span><span class="cov8" title="1">{
                result = append(result, &amp;pb.Maker{
                        Id:   m.ID,
                        Name: m.Name,
                })
        }</span>
        <span class="cov8" title="1">return result</span>
}

func convertSeriesToPb(series []entity.Series) []*pb.Series <span class="cov8" title="1">{
        var result []*pb.Series
        for _, s := range series </span><span class="cov8" title="1">{
                result = append(result, &amp;pb.Series{
                        Id:   s.ID,
                        Name: s.Name,
                })
        }</span>
        <span class="cov8" title="1">return result</span>
}

func convertDirectorsToPb(directors []entity.Director) []*pb.Director <span class="cov8" title="1">{
        var result []*pb.Director
        for _, d := range directors </span><span class="cov8" title="1">{
                result = append(result, &amp;pb.Director{
                        Id:   d.ID,
                        Name: d.Name,
                })
        }</span>
        <span class="cov8" title="1">return result</span>
}

// レビュー情報の変換関数
func convertReviewToPb(review entity.Review) *pb.Review <span class="cov8" title="1">{
        pbReview := &amp;pb.Review{
                Count:   int32(review.Count),
                Average: review.Average,
        }
        
        // レビュー情報をログに出力
        return pbReview
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package dmmapi

//go:generate mockgen -destination=mock_client.go -package=dmmapi github.com/tikfack/server/internal/infrastructure/dmmapi ClientInterface

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "os"
)

type ClientInterface interface {
    Call(path string, v interface{}) error
}

// Client は DMM API へのリクエストを行う
type Client struct {
    BaseURL     string
    APIID       string
    AffiliateID string
    HTTPClient  *http.Client
}

// NewClient 環境変数から設定を読み込み、新規 Client を返す
func NewClient() (*Client, error) <span class="cov8" title="1">{
    base := os.Getenv("BASE_URL")
    id := os.Getenv("DMM_API_ID")
    aff := os.Getenv("DMM_API_AFFILIATE_ID")
    if base == "" || id == "" || aff == "" </span><span class="cov8" title="1">{
        return nil, fmt.Errorf("DMM API credentials not set")
    }</span>
    <span class="cov8" title="1">return &amp;Client{
        BaseURL:     base,
        APIID:       id,
        AffiliateID: aff,
        HTTPClient:  http.DefaultClient,
    }, nil</span>
}

// Call makes a GET request to the specified path and unmarshals into v
func (c *Client) Call(path string, v interface{}) error <span class="cov8" title="1">{
    url := fmt.Sprintf("%s%s&amp;api_id=%s&amp;affiliate_id=%s&amp;output=json", c.BaseURL, path, c.APIID, c.AffiliateID)
    resp, err := c.HTTPClient.Get(url)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    <span class="cov8" title="1">defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    <span class="cov8" title="1">return json.Unmarshal(body, v)</span>
}</pre>
		
		<pre class="file" id="file9" style="display: none">package dmmapi

import (
        "context"
        "fmt"
        "log/slog"
        "strings"
        "time"

        "github.com/tikfack/server/internal/domain/entity"
        "github.com/tikfack/server/internal/domain/repository"
)

type Repository struct {
    client ClientInterface
    mapper MapperInterface
    logger *slog.Logger
}

type defaultMapper struct{}
func (m defaultMapper) ConvertItem(item Item) entity.Video <span class="cov0" title="0">{
    return ConvertItem(item)
}</span>

// NewRepository 新しい DMM 用 Repository を返す
func NewRepository() (repository.VideoRepository, error) <span class="cov0" title="0">{
    c, err := NewClient()
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>
    <span class="cov0" title="0">return &amp;Repository{
        client: c,
        mapper: defaultMapper{},
        logger: slog.Default().With(slog.String("component", "dmmapi")),
    }, nil</span>
}

// テストやモック注入用
func NewRepositoryWithDeps(client ClientInterface, mapper MapperInterface) repository.VideoRepository <span class="cov8" title="1">{
    return &amp;Repository{
        client: client,
        mapper: mapper,
        logger: slog.Default().With(slog.String("component", "dmmapi")),
    }
}</span>

// NewRepositoryWithLogger creates a repository with a custom logger
func NewRepositoryWithLogger(client ClientInterface, mapper MapperInterface, logger *slog.Logger) repository.VideoRepository <span class="cov0" title="0">{
    return &amp;Repository{
        client: client,
        mapper: mapper,
        logger: logger.With(slog.String("component", "dmmapi")),
    }
}</span>

// SetLogger sets a custom logger for the repository
func (r *Repository) SetLogger(logger *slog.Logger) <span class="cov0" title="0">{
    r.logger = logger.With(slog.String("component", "dmmapi"))
}</span>

// GetVideosByDate は指定日付の動画一覧を取得する
func (r *Repository) GetVideosByDate(ctx context.Context, targetDate time.Time) ([]entity.Video, error) <span class="cov8" title="1">{
    path := fmt.Sprintf(
        "/v3/ItemList?site=FANZA&amp;service=digital&amp;floor=videoa&amp;sort=date&amp;hits=100&amp;gte_date=%s&amp;lte_date=%s",
        time.Date(2022, 4, 1, 0, 0, 0, 0, time.Local).Format("2006-01-02T15:04:05"),
        //targetDate.Format("2006-01-02T15:04:05"),
        time.Date(targetDate.Year(), targetDate.Month(), targetDate.Day(), 23, 59, 0, 0, targetDate.Location()).Format("2006-01-02T15:04:05"),
    )
    r.logger.Debug("calling API", "path", path)
    var resp Response
    if err := r.client.Call(path, &amp;resp); err != nil </span><span class="cov8" title="1">{
        return nil, err
    }</span>
    <span class="cov8" title="1">videos := make([]entity.Video, 0, len(resp.Result.Items))
    for _, item := range resp.Result.Items </span><span class="cov8" title="1">{
        videos = append(videos,r.mapper.ConvertItem(item))
    }</span>
    
    // 先頭5件のみを抽出
    <span class="cov8" title="1">if len(videos) &gt; 0 </span><span class="cov8" title="1">{
        sampleSize := min(5, len(videos))
        sample := videos[:sampleSize]
        
        // サンプルをログに出力
        r.logger.Debug("video results sample", "count", sampleSize, "videos", sample)
    }</span> else<span class="cov8" title="1"> {
        r.logger.Debug("No videos found")
    }</span>
    
    <span class="cov8" title="1">return videos, nil</span>
}

// GetVideoById は指定 ID の動画情報を取得する
func (r *Repository) GetVideoById(ctx context.Context, dmmID string) (*entity.Video, error) <span class="cov8" title="1">{
    path := fmt.Sprintf(
        "/v3/ItemList?site=FANZA&amp;service=digital&amp;floor=videoa&amp;cid=%s",
        dmmID,
    )
    r.logger.Debug("calling API", "path", path)
    var resp Response
    if err := r.client.Call(path, &amp;resp); err != nil </span><span class="cov8" title="1">{
        return nil, err
    }</span>
    <span class="cov8" title="1">if len(resp.Result.Items) == 0 </span><span class="cov8" title="1">{
        return nil, fmt.Errorf("動画ID %s が見つかりませんでした", dmmID)
    }</span>
    <span class="cov8" title="1">v := r.mapper.ConvertItem(resp.Result.Items[0])
    return &amp;v, nil</span>
}

// SearchVideos はキーワードや各種 ID で動画を検索する
func (r *Repository) SearchVideos(
    ctx context.Context,
    keyword, actressID, genreID, makerID, seriesID, directorID string,
) ([]entity.Video, error) <span class="cov8" title="1">{
    params := []string{"site=FANZA", "service=digital", "floor=videoa"}
    if keyword != "" </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("keyword=%s", keyword))
    }</span>
    
    // 複数条件のfilterカウンター
    <span class="cov8" title="1">articleIdx := 0
    
    // 女優ID
    if actressID != "" </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("article[%d]=actress", articleIdx))
        params = append(params, fmt.Sprintf("article_id[%d]=%s", articleIdx, actressID))
        articleIdx++
    }</span>
    
    // ジャンルID
    <span class="cov8" title="1">if genreID != "" </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("article[%d]=genre", articleIdx))
        params = append(params, fmt.Sprintf("article_id[%d]=%s", articleIdx, genreID))
        articleIdx++
    }</span>
    
    // メーカーID
    <span class="cov8" title="1">if makerID != "" </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("article[%d]=maker", articleIdx))
        params = append(params, fmt.Sprintf("article_id[%d]=%s", articleIdx, makerID))
        articleIdx++
    }</span>
    
    // シリーズID
    <span class="cov8" title="1">if seriesID != "" </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("article[%d]=series", articleIdx))
        params = append(params, fmt.Sprintf("article_id[%d]=%s", articleIdx, seriesID))
        articleIdx++
    }</span>
    
    // 監督ID
    <span class="cov8" title="1">if directorID != "" </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("article[%d]=director", articleIdx))
        params = append(params, fmt.Sprintf("article_id[%d]=%s", articleIdx, directorID))
        articleIdx++
    }</span>
    
    <span class="cov8" title="1">path := "/v3/ItemList?" + strings.Join(params, "&amp;")
    r.logger.Debug("calling API", "path", path)
    var resp Response
    if err := r.client.Call(path, &amp;resp); err != nil </span><span class="cov8" title="1">{
        return nil, err
    }</span>
    <span class="cov8" title="1">videos := make([]entity.Video, 0, len(resp.Result.Items))
    for _, item := range resp.Result.Items </span><span class="cov8" title="1">{
        videos = append(videos,r.mapper.ConvertItem(item))
    }</span>
    <span class="cov8" title="1">return videos, nil</span>
}

// GetVideosByID は ID 一覧から動画を検索
func (r *Repository) GetVideosByID(
    ctx context.Context,
    actressIDs, genreIDs, makerIDs, seriesIDs, directorIDs []string,
    hits int32,
    offset int32,
    sort, gteDate, lteDate, site, service, floor string,
) ([]entity.Video, error) <span class="cov8" title="1">{
    // パラメータ組み立て
    params := []string{
        fmt.Sprintf("site=%s", defaultIfEmpty(site, "FANZA")),
        fmt.Sprintf("service=%s", defaultIfEmpty(service, "digital")),
        fmt.Sprintf("floor=%s", defaultIfEmpty(floor, "videoa")),
    }
    if hits &gt; 0 </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("hits=%d", hits))
    }</span>
    <span class="cov8" title="1">if offset &gt; 0 </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("offset=%d", offset))
    }</span>
    <span class="cov8" title="1">if sort != "" </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("sort=%s", sort))
    }</span>
    <span class="cov8" title="1">if gteDate != "" </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("gte_date=%s", gteDate))
    }</span>
    <span class="cov8" title="1">if lteDate != "" </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("lte_date=%s", lteDate))
    }</span>

    // 複数条件のfilterカウンター
    <span class="cov8" title="1">articleIdx := 0
    
    // actressIDs - 女優
    for _, id := range actressIDs </span><span class="cov8" title="1">{
        if id != "" </span><span class="cov8" title="1">{
            params = append(params, fmt.Sprintf("article[%d]=actress", articleIdx))
            params = append(params, fmt.Sprintf("article_id[%d]=%s", articleIdx, id))
            articleIdx++
        }</span>
    }
    
    // genreIDs - ジャンル
    <span class="cov8" title="1">for _, id := range genreIDs </span><span class="cov8" title="1">{
        if id != "" </span><span class="cov8" title="1">{
            params = append(params, fmt.Sprintf("article[%d]=genre", articleIdx))
            params = append(params, fmt.Sprintf("article_id[%d]=%s", articleIdx, id))
            articleIdx++
        }</span>
    }
    
    // makerIDs - メーカー
    <span class="cov8" title="1">for _, id := range makerIDs </span><span class="cov8" title="1">{
        if id != "" </span><span class="cov8" title="1">{
            params = append(params, fmt.Sprintf("article[%d]=maker", articleIdx))
            params = append(params, fmt.Sprintf("article_id[%d]=%s", articleIdx, id))
            articleIdx++
        }</span>
    }
    
    // seriesIDs - シリーズ
    <span class="cov8" title="1">for _, id := range seriesIDs </span><span class="cov8" title="1">{
        if id != "" </span><span class="cov8" title="1">{
            params = append(params, fmt.Sprintf("article[%d]=series", articleIdx))
            params = append(params, fmt.Sprintf("article_id[%d]=%s", articleIdx, id))
            articleIdx++
        }</span>
    }
    
    // directorIDs - 監督
    <span class="cov8" title="1">for _, id := range directorIDs </span><span class="cov8" title="1">{
        if id != "" </span><span class="cov8" title="1">{
            params = append(params, fmt.Sprintf("article[%d]=director", articleIdx))
            params = append(params, fmt.Sprintf("article_id[%d]=%s", articleIdx, id))
            articleIdx++
        }</span>
    }
    
    <span class="cov8" title="1">path := "/v3/ItemList?" + strings.Join(params, "&amp;")
    r.logger.Debug("calling API", "path", path)
    var resp Response
    if err := r.client.Call(path, &amp;resp); err != nil </span><span class="cov8" title="1">{
        return nil, err
    }</span>
    <span class="cov8" title="1">videos := make([]entity.Video, 0, len(resp.Result.Items))
    for _, item := range resp.Result.Items </span><span class="cov8" title="1">{
        videos = append(videos,r.mapper.ConvertItem(item))
    }</span>
    <span class="cov8" title="1">return videos, nil</span>
}

// GetVideosByKeyword はキーワード検索を行う
func (r *Repository) GetVideosByKeyword(
    ctx context.Context,
    keyword string,
    hits int32,
    offset int32,
    sort, gteDate, lteDate, site, service, floor string,
) ([]entity.Video, error) <span class="cov8" title="1">{
    params := []string{
        fmt.Sprintf("site=%s", defaultIfEmpty(site, "FANZA")),
        fmt.Sprintf("service=%s", defaultIfEmpty(service, "digital")),
        fmt.Sprintf("floor=%s", defaultIfEmpty(floor, "videoa")),
    }
    if keyword != "" </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("keyword=%s", keyword))
    }</span>
    <span class="cov8" title="1">if hits &gt; 0 </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("hits=%d", hits))
    }</span>
    <span class="cov8" title="1">if offset &gt; 0 </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("offset=%d", offset))
    }</span>
    <span class="cov8" title="1">if sort != "" </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("sort=%s", sort))
    }</span>
    <span class="cov8" title="1">if gteDate != "" </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("gte_date=%s", gteDate))
    }</span>
    <span class="cov8" title="1">if lteDate != "" </span><span class="cov8" title="1">{
        params = append(params, fmt.Sprintf("lte_date=%s", lteDate))
    }</span>
    
    <span class="cov8" title="1">path := "/v3/ItemList?" + strings.Join(params, "&amp;")
    r.logger.Debug("calling API", "path", path)
    var resp Response
    if err := r.client.Call(path, &amp;resp); err != nil </span><span class="cov8" title="1">{
        return nil, err
    }</span>
    <span class="cov8" title="1">videos := make([]entity.Video, 0, len(resp.Result.Items))
    for _, item := range resp.Result.Items </span><span class="cov8" title="1">{
        videos = append(videos,r.mapper.ConvertItem(item))
    }</span>
    <span class="cov8" title="1">return videos, nil</span>
}

// defaultIfEmpty は空文字列のときデフォルト値を返す
func defaultIfEmpty(s, def string) string <span class="cov8" title="1">{
    if s == "" </span><span class="cov8" title="1">{
        return def
    }</span>
    <span class="cov8" title="1">return s</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">package dmmapi

//go:generate mockgen -destination=mock_mapper.go -package=dmmapi github.com/tikfack/server/internal/infrastructure/dmmapi MapperInterface

import (
        "strconv"
        "strings"
        "time"

        "github.com/tikfack/server/internal/domain/entity"
)

type MapperInterface interface {
    ConvertItem(item Item) entity.Video
}

// ConvertItem は dmmapi.Item を entity.Video に変換する
func ConvertItem(item Item) entity.Video <span class="cov8" title="1">{
    // 価格や日付のパースなどロジックをここに集約
    price := parsePrice(item)
    created := parseDate(item.Date)

    // actor/genre/maker などの変換
    var actresses []entity.Actress
    for _, a := range item.ItemInfo.Actress </span><span class="cov8" title="1">{
        actresses = append(actresses, entity.Actress{ID: strconv.Itoa(a.ID), Name: a.Name})
    }</span>
    
    // genres変換
    <span class="cov8" title="1">var genres []entity.Genre
    for _, g := range item.ItemInfo.Genre </span><span class="cov8" title="1">{
        genres = append(genres, entity.Genre{ID: strconv.Itoa(g.ID), Name: g.Name})
    }</span>
    
    // makers変換
    <span class="cov8" title="1">var makers []entity.Maker
    for _, m := range item.ItemInfo.Maker </span><span class="cov8" title="1">{
        makers = append(makers, entity.Maker{ID: strconv.Itoa(m.ID), Name: m.Name})
    }</span>
    
    // series変換
    <span class="cov8" title="1">var series []entity.Series
    for _, s := range item.ItemInfo.Series </span><span class="cov8" title="1">{
        series = append(series, entity.Series{ID: strconv.Itoa(s.ID), Name: s.Name})
    }</span>
    
    // directors変換
    <span class="cov8" title="1">var directors []entity.Director
    for _, d := range item.ItemInfo.Director </span><span class="cov8" title="1">{
        directors = append(directors, entity.Director{ID: strconv.Itoa(d.ID), Name: d.Name})
    }</span>
    
    // サンプル動画URL
    <span class="cov8" title="1">var sampleURL string
    if item.SampleMovieURL != nil </span><span class="cov8" title="1">{
        sampleURL = item.SampleMovieURL.Size720480
    }</span>

    // レビュー情報
    // デフォルト値を設定（将来的にDMM APIがレビュー情報を提供した場合に更新）
    <span class="cov8" title="1">review := entity.Review{
        Count:   0,
        Average: 0,
    }
    if item.Review != nil </span><span class="cov8" title="1">{
        review.Count = item.Review.Count
        
        // 文字列の平均値を数値に変換
        if average, err := strconv.ParseFloat(item.Review.Average, 32); err == nil </span><span class="cov8" title="1">{
            review.Average = float32(average)
        }</span>
        
    }

    <span class="cov8" title="1">video := entity.Video{
        DmmID:        item.ContentID,
        Title:        item.Title,
        DirectURL:    sampleURL, // サンプル動画URLをDirectURLとして使用
        URL:          item.URL,
        SampleURL:    sampleURL,
        ThumbnailURL: item.ImageURL.Large,
        CreatedAt:    created,
        Price:        price,
        LikesCount:   0, // APIからは取得できないのでデフォルト値0を設定
        Actresses:    actresses,
        Genres:       genres,
        Makers:       makers,
        Series:       series,
        Directors:    directors,
        Review:       review,
    }


    return video</span>
}

func parsePrice(item Item) int <span class="cov8" title="1">{
    // サンプル実装
    s := strings.ReplaceAll(item.Prices.Price, "円", "")
    p, _ := strconv.Atoi(strings.ReplaceAll(s, "~", ""))
    return p
}</span>

func parseDate(dateStr string) time.Time <span class="cov8" title="1">{
    t, _ := time.Parse("2006-01-02 15:04:05", dateStr)
    return t
}</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/tikfack/server/internal/infrastructure/dmmapi (interfaces: ClientInterface)

// Package dmmapi is a generated GoMock package.
package dmmapi

import (
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockClientInterface is a mock of ClientInterface interface.
type MockClientInterface struct {
        ctrl     *gomock.Controller
        recorder *MockClientInterfaceMockRecorder
}

// MockClientInterfaceMockRecorder is the mock recorder for MockClientInterface.
type MockClientInterfaceMockRecorder struct {
        mock *MockClientInterface
}

// NewMockClientInterface creates a new mock instance.
func NewMockClientInterface(ctrl *gomock.Controller) *MockClientInterface <span class="cov8" title="1">{
        mock := &amp;MockClientInterface{ctrl: ctrl}
        mock.recorder = &amp;MockClientInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClientInterface) EXPECT() *MockClientInterfaceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Call mocks base method.
func (m *MockClientInterface) Call(arg0 string, arg1 interface{}) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Call", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Call indicates an expected call of Call.
func (mr *MockClientInterfaceMockRecorder) Call(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Call", reflect.TypeOf((*MockClientInterface)(nil).Call), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/tikfack/server/internal/infrastructure/dmmapi (interfaces: MapperInterface)

// Package dmmapi is a generated GoMock package.
package dmmapi

import (
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
        entity "github.com/tikfack/server/internal/domain/entity"
)

// MockMapperInterface is a mock of MapperInterface interface.
type MockMapperInterface struct {
        ctrl     *gomock.Controller
        recorder *MockMapperInterfaceMockRecorder
}

// MockMapperInterfaceMockRecorder is the mock recorder for MockMapperInterface.
type MockMapperInterfaceMockRecorder struct {
        mock *MockMapperInterface
}

// NewMockMapperInterface creates a new mock instance.
func NewMockMapperInterface(ctrl *gomock.Controller) *MockMapperInterface <span class="cov8" title="1">{
        mock := &amp;MockMapperInterface{ctrl: ctrl}
        mock.recorder = &amp;MockMapperInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMapperInterface) EXPECT() *MockMapperInterfaceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// ConvertItem mocks base method.
func (m *MockMapperInterface) ConvertItem(arg0 Item) entity.Video <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ConvertItem", arg0)
        ret0, _ := ret[0].(entity.Video)
        return ret0
}</span>

// ConvertItem indicates an expected call of ConvertItem.
func (mr *MockMapperInterfaceMockRecorder) ConvertItem(arg0 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertItem", reflect.TypeOf((*MockMapperInterface)(nil).ConvertItem), arg0)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package repository

import (
        "github.com/tikfack/server/internal/domain/repository"
        "github.com/tikfack/server/internal/infrastructure/dmmapi"
)

// NewVideoRepository は domain.VideoRepository の実装を返す
// dmmapi.repositoryを返すだけなのでテスト不要
func NewVideoRepository() (repository.VideoRepository, error) <span class="cov0" title="0">{
    // 今は DMM API 実装を返す
    return dmmapi.NewRepository()
}</pre>
		
		<pre class="file" id="file14" style="display: none">package util

import (
        "fmt"
        "net/http"
        "regexp"
)

// GetValidVideoUrl は DMM ID から実際の動画配信URLを検証して取得します
func GetValidVideoUrl(dmmVideoId string) (string, error) <span class="cov8" title="1">{
        var reAlt0 = regexp.MustCompile(`^([A-Za-z0-9_]+?)0(\d+)([A-Za-z])?$`)
        var reAlt00 = regexp.MustCompile(`^([A-Za-z0-9_]+?)00(\d+)([A-Za-z])?$`)
        
        generateUrl := func(id string) string </span><span class="cov8" title="1">{
                if len(id) &lt; 3 </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov8" title="1">firstChar := id[0:1]
                firstThreeChars := id[0:3]
                return fmt.Sprintf("https://cc3001.dmm.co.jp/litevideo/freepv/%s/%s/%s/%smhb.mp4", firstChar, firstThreeChars, id, id)</span>
        }

        <span class="cov8" title="1">originalUrl := generateUrl(dmmVideoId)
        alternativeUrl0 := generateUrl(reAlt0.ReplaceAllString(dmmVideoId, "$1$2$3"))
        alternativeUrl00 := generateUrl(reAlt00.ReplaceAllString(dmmVideoId, "$1$2$3"))

        urls := []string{originalUrl, alternativeUrl0, alternativeUrl00}
        for _, url := range urls </span><span class="cov8" title="1">{
                resp, err := http.Head(url)
                if err == nil &amp;&amp; resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300 </span><span class="cov8" title="1">{
                        return url, nil
                }</span>
        }
        <span class="cov8" title="1">return "", fmt.Errorf("有効な動画URLが見つかりませんでした: %s", dmmVideoId)</span>
} </pre>
		
		<pre class="file" id="file15" style="display: none">package main

import (
        "log/slog"
        "net/http"
        "os"

        "github.com/joho/godotenv"
        "github.com/rs/cors"

        connecthandler "github.com/tikfack/server/internal/infrastructure/connect"
)

func main() <span class="cov0" title="0">{
        // 環境変数の読み込み
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                // .envファイルがなくてもエラーではない（本番環境では環境変数で設定する場合がある）
                slog.Info("環境変数を.envから読み込めませんでした", "error", err)
        }</span>

        // ログレベルの設定
        <span class="cov0" title="0">logLevel := os.Getenv("LOG_LEVEL")
        setupLogger(logLevel)

        port := os.Getenv("PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "50051"
        }</span>

        <span class="cov0" title="0">videoHandler := connecthandler.NewVideoServiceHandler()
        mux := http.NewServeMux()
        pattern, handler := videoHandler.GetHandler()
        mux.Handle(pattern, handler)

        // ミドルウェアチェイン
        loggedHandler := loggingMiddleware(mux)
        handlerWithCORS := cors.AllowAll().Handler(loggedHandler)

        slog.Info("サーバーを起動しています", "port", port)
        if err := http.ListenAndServe(":"+port, handlerWithCORS); err != nil </span><span class="cov0" title="0">{
                slog.Error("サーバー起動に失敗しました", "error", err)
                os.Exit(1)
        }</span>
}

// setupLogger configures the global slog logger based on the environment
func setupLogger(level string) <span class="cov0" title="0">{
        var logLevel slog.Level
        switch level </span>{
        case "debug":<span class="cov0" title="0">
                logLevel = slog.LevelDebug</span>
        case "info":<span class="cov0" title="0">
                logLevel = slog.LevelInfo</span>
        case "warn":<span class="cov0" title="0">
                logLevel = slog.LevelWarn</span>
        case "error":<span class="cov0" title="0">
                logLevel = slog.LevelError</span>
        default:<span class="cov0" title="0">
                logLevel = slog.LevelInfo</span> // デフォルトはInfo
        }

        // JSONハンドラーを使用
        <span class="cov0" title="0">opts := &amp;slog.HandlerOptions{
                Level: logLevel,
        }
        logger := slog.New(slog.NewJSONHandler(os.Stdout, opts))
        slog.SetDefault(logger)

        logger.Info("ロガーを設定しました", "level", logLevel.String())</span>
}

func loggingMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                slog.Info("新しいリクエスト", 
                        "method", r.Method, 
                        "path", r.URL.Path, 
                        "remote_addr", r.RemoteAddr)
                next.ServeHTTP(w, r)
        }</span>)
}</pre>
		
		<pre class="file" id="file16" style="display: none">package main

import (
        "log/slog"
        "net/http"
        "os"

        "github.com/bufbuild/connect-go"
        "go.uber.org/mock/gomock"

        // protoから生成したパッケージ
        "context"

        "github.com/joho/godotenv"
        "github.com/rs/cors"
        pb "github.com/tikfack/server/gen/video"
        videopbconnect "github.com/tikfack/server/gen/video/videoconnect"
        mockpb "github.com/tikfack/server/internal/infrastructure/connect/mock"
)

func main() <span class="cov0" title="0">{
        // 環境変数の読み込み
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                // .envファイルがなくてもエラーではない（本番環境では環境変数で設定する場合がある）
                slog.Info("環境変数を.envから読み込めませんでした", "error", err)
        }</span>

        // ログレベルの設定
        <span class="cov0" title="0">logLevel := os.Getenv("LOG_LEVEL")
        setupLogger(logLevel)

        port := os.Getenv("PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "50051"
        }</span>

    <span class="cov0" title="0">ctrl := gomock.NewController(nil)
        mockHandler := mockpb.NewMockVideoServiceHandler(ctrl)

        // モックの実装
        mockHandler.EXPECT().
                GetVideosByDate(gomock.Any(), gomock.Any()).
        DoAndReturn(func(ctx context.Context, req *connect.Request[pb.GetVideosByDateRequest]) (*connect.Response[pb.GetVideosByDateResponse], error) </span><span class="cov0" title="0">{
            videos := []*pb.Video{
                {
                    DmmId:        "DUMMY001",
                    Title:        "サンプル動画タイトル1",
                    DirectUrl:    "https://example.com/videos/1",
                    Url:          "https://dmm.com/video/1",
                    SampleUrl:    "https://example.com/sample/1.mp4",
                    ThumbnailUrl: "https://example.com/thumbs/1.jpg",
                    CreatedAt:    "2024-05-19T00:00:00Z",
                    Price:        2980,
                    LikesCount:   123,
    
                    Actresses: []*pb.Actress{
                        {Id: "A001", Name: "佐藤花子"},
                        {Id: "A002", Name: "鈴木美咲"},
                    },
                    Genres: []*pb.Genre{
                        {Id: "G001", Name: "ドラマ"},
                        {Id: "G002", Name: "ロマンス"},
                    },
                    Makers: []*pb.Maker{
                        {Id: "M001", Name: "メーカーテスト"},
                    },
                    Series: []*pb.Series{
                        {Id: "S001", Name: "シリーズサンプル"},
                    },
                    Directors: []*pb.Director{
                        {Id: "D001", Name: "山田太郎"},
                    },
                    Review: &amp;pb.Review{
                        Count:     100,
                        Average:  4.5,
                    },
                },
                {
                    DmmId:        "DUMMY002",
                    Title:        "サンプル動画タイトル2",
                    DirectUrl:    "https://example.com/videos/2",
                    Url:          "https://dmm.com/video/2",
                    SampleUrl:    "https://example.com/sample/2.mp4",
                    ThumbnailUrl: "https://example.com/thumbs/2.jpg",
                    CreatedAt:    "2024-05-18T00:00:00Z",
                    Price:        1980,
                    LikesCount:   87,
    
                    Actresses: []*pb.Actress{
                        {Id: "A003", Name: "高橋彩"},
                    },
                    Genres: []*pb.Genre{
                        {Id: "G003", Name: "アクション"},
                    },
                    Makers: []*pb.Maker{
                        {Id: "M002", Name: "テストメーカー2"},
                    },
                    Series: []*pb.Series{
                        {Id: "S002", Name: "シリーズ2"},
                    },
                    Directors: []*pb.Director{
                        {Id: "D002", Name: "佐々木健"},
                    },
                    Review: &amp;pb.Review{
                        Count:     100,
                        Average:  3.0,
                    },
                },
            }
            resp := &amp;pb.GetVideosByDateResponse{Videos: videos}
            return connect.NewResponse(resp), nil
        }</span>).
        AnyTimes()

    <span class="cov0" title="0">pattern, handler := videopbconnect.NewVideoServiceHandler(mockHandler)
        mux := http.NewServeMux()
        mux.Handle(pattern, handler)

        // ミドルウェアチェイン
        loggedHandler := loggingMiddleware(mux)
        handlerWithCORS := cors.AllowAll().Handler(loggedHandler)

        slog.Info("サーバーを起動しています", "port", port)
        if err := http.ListenAndServe(":"+port, handlerWithCORS); err != nil </span><span class="cov0" title="0">{
                slog.Error("サーバー起動に失敗しました", "error", err)
                os.Exit(1)
        }</span>
}

// setupLogger configures the global slog logger based on the environment
func setupLogger(level string) <span class="cov0" title="0">{
        var logLevel slog.Level
        switch level </span>{
        case "debug":<span class="cov0" title="0">
                logLevel = slog.LevelDebug</span>
        case "info":<span class="cov0" title="0">
                logLevel = slog.LevelInfo</span>
        case "warn":<span class="cov0" title="0">
                logLevel = slog.LevelWarn</span>
        case "error":<span class="cov0" title="0">
                logLevel = slog.LevelError</span>
        default:<span class="cov0" title="0">
                logLevel = slog.LevelInfo</span> // デフォルトはInfo
        }

        // JSONハンドラーを使用
        <span class="cov0" title="0">opts := &amp;slog.HandlerOptions{
                Level: logLevel,
        }
        logger := slog.New(slog.NewJSONHandler(os.Stdout, opts))
        slog.SetDefault(logger)

        logger.Info("ロガーを設定しました", "level", logLevel.String())</span>
}

func loggingMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                slog.Info("新しいリクエスト", 
                        "method", r.Method, 
                        "path", r.URL.Path, 
                        "remote_addr", r.RemoteAddr)
                next.ServeHTTP(w, r)
        }</span>)
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
